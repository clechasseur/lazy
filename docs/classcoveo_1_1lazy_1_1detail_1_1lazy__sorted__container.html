<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coveo::lazy: coveo::lazy::detail::lazy_sorted_container&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coveo::lazy
   </div>
   <div id="projectbrief">Associative containers that perform lazy sorting</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>coveo</b></li><li class="navelem"><b>lazy</b></li><li class="navelem"><b>detail</b></li><li class="navelem"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">coveo::lazy::detail::lazy_sorted_container&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Template base class for lazy-sorted associative containers.  
 <a href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for coveo::lazy::detail::lazy_sorted_container&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.png" usemap="#coveo::lazy::detail::lazy_5Fsorted_5Fcontainer_3C_20K_2C_20T_2C_20V_2C_20PubV_2C_20VToK_2C_20KCmp_2C_20KEq_2C_20Alloc_2C_20Impl_2C_20Multi_2C_20_5FIsNonMultiMap_20_3E_map" alt=""/>
  <map id="coveo::lazy::detail::lazy_5Fsorted_5Fcontainer_3C_20K_2C_20T_2C_20V_2C_20PubV_2C_20VToK_2C_20KCmp_2C_20KEq_2C_20Alloc_2C_20Impl_2C_20Multi_2C_20_5FIsNonMultiMap_20_3E_map" name="coveo::lazy::detail::lazy_5Fsorted_5Fcontainer_3C_20K_2C_20T_2C_20V_2C_20PubV_2C_20VToK_2C_20KCmp_2C_20KEq_2C_20Alloc_2C_20Impl_2C_20Multi_2C_20_5FIsNonMultiMap_20_3E_map">
<area href="structcoveo_1_1lazy_1_1detail_1_1mapped__type__base.html" title="Base class for lazy-sorted containers. " alt="coveo::lazy::detail::mapped_type_base&lt; T &gt;" shape="rect" coords="1015,0,1682,24"/>
<area href="classcoveo_1_1lazy_1_1map.html" title="Map container that performs lazy sorting. " alt="coveo::lazy::map" shape="rect" coords="0,112,667,136"/>
<area href="classcoveo_1_1lazy_1_1multimap.html" title="Multimap container that performs lazy sorting. " alt="coveo::lazy::multimap" shape="rect" coords="677,112,1344,136"/>
<area href="classcoveo_1_1lazy_1_1multiset.html" title="Multiset container that performs lazy sorting. " alt="coveo::lazy::multiset" shape="rect" coords="1354,112,2021,136"/>
<area href="classcoveo_1_1lazy_1_1set.html" title="Set container that performs lazy sorting. " alt="coveo::lazy::set" shape="rect" coords="2031,112,2698,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1070c870bcc7121d722e529091d7db5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1070c870bcc7121d722e529091d7db5c">container_impl</a> = Impl&lt; V, Alloc &gt;</td></tr>
<tr class="memdesc:a1070c870bcc7121d722e529091d7db5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of container used internally.  <a href="#a1070c870bcc7121d722e529091d7db5c">More...</a><br /></td></tr>
<tr class="separator:a1070c870bcc7121d722e529091d7db5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba0ad7eac9d43f801936289bfd02ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71ba0ad7eac9d43f801936289bfd02ca">iterator_impl</a> = typename container_impl::iterator</td></tr>
<tr class="memdesc:a71ba0ad7eac9d43f801936289bfd02ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal container's <code>iterator</code> implementation.  <a href="#a71ba0ad7eac9d43f801936289bfd02ca">More...</a><br /></td></tr>
<tr class="separator:a71ba0ad7eac9d43f801936289bfd02ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519484d4c227157bd1eb7be058bc451"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae519484d4c227157bd1eb7be058bc451">const_iterator_impl</a> = typename container_impl::const_iterator</td></tr>
<tr class="memdesc:ae519484d4c227157bd1eb7be058bc451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal container's <code>const_iterator</code> implementation.  <a href="#ae519484d4c227157bd1eb7be058bc451">More...</a><br /></td></tr>
<tr class="separator:ae519484d4c227157bd1eb7be058bc451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eea9bb86b455cc9e0db77d7b1b921a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a16eea9bb86b455cc9e0db77d7b1b921a">reverse_iterator_impl</a> = typename container_impl::reverse_iterator</td></tr>
<tr class="memdesc:a16eea9bb86b455cc9e0db77d7b1b921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal container's <code>reverse_iterator</code> implementation.  <a href="#a16eea9bb86b455cc9e0db77d7b1b921a">More...</a><br /></td></tr>
<tr class="separator:a16eea9bb86b455cc9e0db77d7b1b921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af041cae494495d51d4f4d0b7efb1825f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af041cae494495d51d4f4d0b7efb1825f">const_reverse_iterator_impl</a> = typename container_impl::const_reverse_iterator</td></tr>
<tr class="memdesc:af041cae494495d51d4f4d0b7efb1825f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal container's <code>const_reverse_iterator</code> implementation.  <a href="#af041cae494495d51d4f4d0b7efb1825f">More...</a><br /></td></tr>
<tr class="separator:af041cae494495d51d4f4d0b7efb1825f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d87e2c555de098553572019237979"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> = K</td></tr>
<tr class="memdesc:a928d87e2c555de098553572019237979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of keys used by the container.  <a href="#a928d87e2c555de098553572019237979">More...</a><br /></td></tr>
<tr class="separator:a928d87e2c555de098553572019237979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1adb4d1df12a412203b3c430ec2fe5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> = PubV</td></tr>
<tr class="memdesc:a2a1adb4d1df12a412203b3c430ec2fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of elements stored in the container.  <a href="#a2a1adb4d1df12a412203b3c430ec2fe5">More...</a><br /></td></tr>
<tr class="separator:a2a1adb4d1df12a412203b3c430ec2fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad190c239a267ade61f32b53d36bc7756"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> = typename container_impl::size_type</td></tr>
<tr class="memdesc:ad190c239a267ade61f32b53d36bc7756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent size of container.  <a href="#ad190c239a267ade61f32b53d36bc7756">More...</a><br /></td></tr>
<tr class="separator:ad190c239a267ade61f32b53d36bc7756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06dab66acc7c765937c610f340d5fe3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa06dab66acc7c765937c610f340d5fe3">difference_type</a> = typename container_impl::difference_type</td></tr>
<tr class="memdesc:aa06dab66acc7c765937c610f340d5fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent difference in the container.  <a href="#aa06dab66acc7c765937c610f340d5fe3">More...</a><br /></td></tr>
<tr class="separator:aa06dab66acc7c765937c610f340d5fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71901dcea412345113a8c68e2ac2a7cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf">value_to_key</a> = VToK</td></tr>
<tr class="memdesc:a71901dcea412345113a8c68e2ac2a7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to get keys from values.  <a href="#a71901dcea412345113a8c68e2ac2a7cf">More...</a><br /></td></tr>
<tr class="separator:a71901dcea412345113a8c68e2ac2a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9790c06988eb20ef24e9a31fb9f693"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> = KCmp</td></tr>
<tr class="memdesc:aaf9790c06988eb20ef24e9a31fb9f693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to compare keys.  <a href="#aaf9790c06988eb20ef24e9a31fb9f693">More...</a><br /></td></tr>
<tr class="separator:aaf9790c06988eb20ef24e9a31fb9f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12921d1e83b7146f0ee0473a5aeb9abf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12921d1e83b7146f0ee0473a5aeb9abf">value_compare</a> = lazy_value_pred_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf">value_to_key</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &gt;</td></tr>
<tr class="memdesc:a12921d1e83b7146f0ee0473a5aeb9abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to compare values.  <a href="#a12921d1e83b7146f0ee0473a5aeb9abf">More...</a><br /></td></tr>
<tr class="separator:a12921d1e83b7146f0ee0473a5aeb9abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1058770dfbe6eaa26f4932621baa3b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> = KEq</td></tr>
<tr class="memdesc:aa1058770dfbe6eaa26f4932621baa3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to check keys for equality.  <a href="#aa1058770dfbe6eaa26f4932621baa3b1">More...</a><br /></td></tr>
<tr class="separator:aa1058770dfbe6eaa26f4932621baa3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7a2e628de794fee63e50acc37626dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4e7a2e628de794fee63e50acc37626dc">value_equal_to</a> = lazy_value_pred_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf">value_to_key</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &gt;</td></tr>
<tr class="memdesc:a4e7a2e628de794fee63e50acc37626dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to check values for equality.  <a href="#a4e7a2e628de794fee63e50acc37626dc">More...</a><br /></td></tr>
<tr class="separator:a4e7a2e628de794fee63e50acc37626dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15ef0131b874fe7fba7814417220af6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> = typename container_impl::allocator_type</td></tr>
<tr class="memdesc:ab15ef0131b874fe7fba7814417220af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator used.  <a href="#ab15ef0131b874fe7fba7814417220af6">More...</a><br /></td></tr>
<tr class="separator:ab15ef0131b874fe7fba7814417220af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8da0ff3acebc50a10290908b2f199d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae8da0ff3acebc50a10290908b2f199d0">reference</a> = std::conditional_t&lt; std::is_void&lt; T &gt;::value, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp; &gt;</td></tr>
<tr class="memdesc:ae8da0ff3acebc50a10290908b2f199d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of reference returned by <code>iterator</code>s.  <a href="#ae8da0ff3acebc50a10290908b2f199d0">More...</a><br /></td></tr>
<tr class="separator:ae8da0ff3acebc50a10290908b2f199d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51fb1b903e75a55d2c12af0c4e4d971"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af51fb1b903e75a55d2c12af0c4e4d971">const_reference</a> = const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;</td></tr>
<tr class="memdesc:af51fb1b903e75a55d2c12af0c4e4d971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of reference returned by <code>const_iterator</code>s.  <a href="#af51fb1b903e75a55d2c12af0c4e4d971">More...</a><br /></td></tr>
<tr class="separator:af51fb1b903e75a55d2c12af0c4e4d971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074b16ccb091869630e4f6ccda407ab4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a074b16ccb091869630e4f6ccda407ab4">pointer</a> = std::conditional_t&lt; std::is_void&lt; T &gt;::value, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> *, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> * &gt;</td></tr>
<tr class="memdesc:a074b16ccb091869630e4f6ccda407ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer corresponding to <code>reference</code>.  <a href="#a074b16ccb091869630e4f6ccda407ab4">More...</a><br /></td></tr>
<tr class="separator:a074b16ccb091869630e4f6ccda407ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6726689afa484a3a7d6984ae4210c882"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6726689afa484a3a7d6984ae4210c882">const_pointer</a> = const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> *</td></tr>
<tr class="memdesc:a6726689afa484a3a7d6984ae4210c882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer corresponding to <code>const_reference</code>.  <a href="#a6726689afa484a3a7d6984ae4210c882">More...</a><br /></td></tr>
<tr class="separator:a6726689afa484a3a7d6984ae4210c882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab994d852d9c69036baedda02d49f7461"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> = std::conditional_t&lt; std::is_void&lt; T &gt;::value, conditional_iterator_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae519484d4c227157bd1eb7be058bc451">const_iterator_impl</a>, const V, const PubV &gt;, conditional_iterator_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71ba0ad7eac9d43f801936289bfd02ca">iterator_impl</a>, V, PubV &gt; &gt;</td></tr>
<tr class="memdesc:ab994d852d9c69036baedda02d49f7461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for the container.  <a href="#ab994d852d9c69036baedda02d49f7461">More...</a><br /></td></tr>
<tr class="separator:ab994d852d9c69036baedda02d49f7461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d70f01d26bac41bcc86efaf54f63d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> = conditional_iterator_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae519484d4c227157bd1eb7be058bc451">const_iterator_impl</a>, const V, const PubV &gt;</td></tr>
<tr class="memdesc:a94d70f01d26bac41bcc86efaf54f63d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for the container.  <a href="#a94d70f01d26bac41bcc86efaf54f63d2">More...</a><br /></td></tr>
<tr class="separator:a94d70f01d26bac41bcc86efaf54f63d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159ac69242a5bd742acadbe13083de84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84">reverse_iterator</a> = std::conditional_t&lt; std::is_void&lt; T &gt;::value, conditional_iterator_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af041cae494495d51d4f4d0b7efb1825f">const_reverse_iterator_impl</a>, const V, const PubV &gt;, conditional_iterator_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a16eea9bb86b455cc9e0db77d7b1b921a">reverse_iterator_impl</a>, V, PubV &gt; &gt;</td></tr>
<tr class="memdesc:a159ac69242a5bd742acadbe13083de84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator for the container.  <a href="#a159ac69242a5bd742acadbe13083de84">More...</a><br /></td></tr>
<tr class="separator:a159ac69242a5bd742acadbe13083de84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c621bb82c8805aec32d8d6ae01bcac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a> = conditional_iterator_proxy&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af041cae494495d51d4f4d0b7efb1825f">const_reverse_iterator_impl</a>, const V, const PubV &gt;</td></tr>
<tr class="memdesc:ac5c621bb82c8805aec32d8d6ae01bcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator for the container.  <a href="#ac5c621bb82c8805aec32d8d6ae01bcac">More...</a><br /></td></tr>
<tr class="separator:ac5c621bb82c8805aec32d8d6ae01bcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structcoveo_1_1lazy_1_1detail_1_1mapped__type__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structcoveo_1_1lazy_1_1detail_1_1mapped__type__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structcoveo_1_1lazy_1_1detail_1_1mapped__type__base.html">coveo::lazy::detail::mapped_type_base&lt; T &gt;</a></td></tr>
<tr class="memitem:a5480a2a8fe83e8210f980c18d919842b inherit pub_types_structcoveo_1_1lazy_1_1detail_1_1mapped__type__base"><td class="memItemLeft" align="right" valign="top"><a id="a5480a2a8fe83e8210f980c18d919842b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoveo_1_1lazy_1_1detail_1_1mapped__type__base.html#a5480a2a8fe83e8210f980c18d919842b">mapped_type</a> = T</td></tr>
<tr class="memdesc:a5480a2a8fe83e8210f980c18d919842b inherit pub_types_structcoveo_1_1lazy_1_1detail_1_1mapped__type__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of values stored in the map. Absent for set-like containers. <br /></td></tr>
<tr class="separator:a5480a2a8fe83e8210f980c18d919842b inherit pub_types_structcoveo_1_1lazy_1_1detail_1_1mapped__type__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afcc5e2058d1e9f7cc73c90f38ad6172e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#afcc5e2058d1e9f7cc73c90f38ad6172e">lazy_sorted_container</a> ()</td></tr>
<tr class="memdesc:afcc5e2058d1e9f7cc73c90f38ad6172e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#afcc5e2058d1e9f7cc73c90f38ad6172e">More...</a><br /></td></tr>
<tr class="separator:afcc5e2058d1e9f7cc73c90f38ad6172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0d5552d2ec09cf39e636316263f915"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1b0d5552d2ec09cf39e636316263f915">lazy_sorted_container</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &amp;kcmp, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>(), const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &amp;keq=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>())</td></tr>
<tr class="memdesc:a1b0d5552d2ec09cf39e636316263f915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with key comparator.  <a href="#a1b0d5552d2ec09cf39e636316263f915">More...</a><br /></td></tr>
<tr class="separator:a1b0d5552d2ec09cf39e636316263f915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb6931d816ae8cc48d5b5f1684d8bd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a3cb6931d816ae8cc48d5b5f1684d8bd4">lazy_sorted_container</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a3cb6931d816ae8cc48d5b5f1684d8bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with allocator.  <a href="#a3cb6931d816ae8cc48d5b5f1684d8bd4">More...</a><br /></td></tr>
<tr class="separator:a3cb6931d816ae8cc48d5b5f1684d8bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7de5778254b7eff302b2d7f96daba1"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a2f7de5778254b7eff302b2d7f96daba1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2f7de5778254b7eff302b2d7f96daba1">lazy_sorted_container</a> (It first, It last, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &amp;kcmp=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a>(), const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>(), const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &amp;keq=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>())</td></tr>
<tr class="memdesc:a2f7de5778254b7eff302b2d7f96daba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor.  <a href="#a2f7de5778254b7eff302b2d7f96daba1">More...</a><br /></td></tr>
<tr class="separator:a2f7de5778254b7eff302b2d7f96daba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678553568e2a992503a632142c4ed969"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a678553568e2a992503a632142c4ed969"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a678553568e2a992503a632142c4ed969">lazy_sorted_container</a> (It first, It last, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a678553568e2a992503a632142c4ed969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor with allocator.  <a href="#a678553568e2a992503a632142c4ed969">More...</a><br /></td></tr>
<tr class="separator:a678553568e2a992503a632142c4ed969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe527256110ba9318363d2ddd40034"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#acfbe527256110ba9318363d2ddd40034">lazy_sorted_container</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;obj)=default</td></tr>
<tr class="memdesc:acfbe527256110ba9318363d2ddd40034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#acfbe527256110ba9318363d2ddd40034">More...</a><br /></td></tr>
<tr class="separator:acfbe527256110ba9318363d2ddd40034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2e266680ccdd9baa14067233d6ab73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0d2e266680ccdd9baa14067233d6ab73">lazy_sorted_container</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;obj, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a0d2e266680ccdd9baa14067233d6ab73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with allocator.  <a href="#a0d2e266680ccdd9baa14067233d6ab73">More...</a><br /></td></tr>
<tr class="separator:a0d2e266680ccdd9baa14067233d6ab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ced06738c803645ae626bae3f1ca7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a86ced06738c803645ae626bae3f1ca7e">lazy_sorted_container</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;&amp;obj)</td></tr>
<tr class="memdesc:a86ced06738c803645ae626bae3f1ca7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a86ced06738c803645ae626bae3f1ca7e">More...</a><br /></td></tr>
<tr class="separator:a86ced06738c803645ae626bae3f1ca7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980323052a71c20f5d59d1731123bf96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a980323052a71c20f5d59d1731123bf96">lazy_sorted_container</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;&amp;obj, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a980323052a71c20f5d59d1731123bf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with allocator.  <a href="#a980323052a71c20f5d59d1731123bf96">More...</a><br /></td></tr>
<tr class="separator:a980323052a71c20f5d59d1731123bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae073314ba9d686dd07420ca7b8719202"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae073314ba9d686dd07420ca7b8719202">lazy_sorted_container</a> (std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt; init, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &amp;kcmp=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a>(), const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>(), const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &amp;keq=<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>())</td></tr>
<tr class="memdesc:ae073314ba9d686dd07420ca7b8719202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list constructor.  <a href="#ae073314ba9d686dd07420ca7b8719202">More...</a><br /></td></tr>
<tr class="separator:ae073314ba9d686dd07420ca7b8719202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8378e179bc9bab9ab391658ce327477a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a8378e179bc9bab9ab391658ce327477a">lazy_sorted_container</a> (std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt; init, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a8378e179bc9bab9ab391658ce327477a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list constructor with allocator.  <a href="#a8378e179bc9bab9ab391658ce327477a">More...</a><br /></td></tr>
<tr class="separator:a8378e179bc9bab9ab391658ce327477a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ddbf38cd8388c1c764fc277975a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a135ddbf38cd8388c1c764fc277975a11">operator=</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;obj)=default</td></tr>
<tr class="memdesc:a135ddbf38cd8388c1c764fc277975a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a135ddbf38cd8388c1c764fc277975a11">More...</a><br /></td></tr>
<tr class="separator:a135ddbf38cd8388c1c764fc277975a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3aa85e8d77197e1c909869bde7c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a62a3aa85e8d77197e1c909869bde7c31">operator=</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;&amp;obj)</td></tr>
<tr class="memdesc:a62a3aa85e8d77197e1c909869bde7c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a62a3aa85e8d77197e1c909869bde7c31">More...</a><br /></td></tr>
<tr class="separator:a62a3aa85e8d77197e1c909869bde7c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b8fa3a736fac2f1ffe55b9b12a059b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a02b8fa3a736fac2f1ffe55b9b12a059b">operator=</a> (std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt; init)</td></tr>
<tr class="memdesc:a02b8fa3a736fac2f1ffe55b9b12a059b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from initializer list.  <a href="#a02b8fa3a736fac2f1ffe55b9b12a059b">More...</a><br /></td></tr>
<tr class="separator:a02b8fa3a736fac2f1ffe55b9b12a059b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4cef589df8fc66eed7fe6bf97b8195"><td class="memTemplParams" colspan="2">template&lt;class _T  = T, class _TRef  = std::enable_if_t&lt;_IsNonMultiMap, _T&amp;&gt;&gt; </td></tr>
<tr class="memitem:a0a4cef589df8fc66eed7fe6bf97b8195"><td class="memTemplItemLeft" align="right" valign="top">_TRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0a4cef589df8fc66eed7fe6bf97b8195">at</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a0a4cef589df8fc66eed7fe6bf97b8195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an existing element.  <a href="#a0a4cef589df8fc66eed7fe6bf97b8195">More...</a><br /></td></tr>
<tr class="separator:a0a4cef589df8fc66eed7fe6bf97b8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7a835cb5bdd921332747f0647e5a09"><td class="memTemplParams" colspan="2">template&lt;class _T  = T, class _CTRef  = std::enable_if_t&lt;_IsNonMultiMap, const _T&amp;&gt;&gt; </td></tr>
<tr class="memitem:a6c7a835cb5bdd921332747f0647e5a09"><td class="memTemplItemLeft" align="right" valign="top">_CTRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6c7a835cb5bdd921332747f0647e5a09">at</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a6c7a835cb5bdd921332747f0647e5a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an existing element (const version).  <a href="#a6c7a835cb5bdd921332747f0647e5a09">More...</a><br /></td></tr>
<tr class="separator:a6c7a835cb5bdd921332747f0647e5a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6679a1cfc0ae878ccb00968bc50f39da"><td class="memTemplParams" colspan="2">template&lt;class _T  = T, class _TRef  = std::enable_if_t&lt;_IsNonMultiMap, _T&amp;&gt;&gt; </td></tr>
<tr class="memitem:a6679a1cfc0ae878ccb00968bc50f39da"><td class="memTemplItemLeft" align="right" valign="top">_TRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6679a1cfc0ae878ccb00968bc50f39da">operator[]</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a6679a1cfc0ae878ccb00968bc50f39da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an element, possibly creating it.  <a href="#a6679a1cfc0ae878ccb00968bc50f39da">More...</a><br /></td></tr>
<tr class="separator:a6679a1cfc0ae878ccb00968bc50f39da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a6f80012a93e8ad0841e466704437e"><td class="memTemplParams" colspan="2">template&lt;class _T  = T, class _TRef  = std::enable_if_t&lt;_IsNonMultiMap, _T&amp;&gt;&gt; </td></tr>
<tr class="memitem:a12a6f80012a93e8ad0841e466704437e"><td class="memTemplItemLeft" align="right" valign="top">_TRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12a6f80012a93e8ad0841e466704437e">operator[]</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&amp;key)</td></tr>
<tr class="memdesc:a12a6f80012a93e8ad0841e466704437e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses an element, possibly creating it (move version).  <a href="#a12a6f80012a93e8ad0841e466704437e">More...</a><br /></td></tr>
<tr class="separator:a12a6f80012a93e8ad0841e466704437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2ee4c56f511d0b57a0b21d281d77c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a2ee4c56f511d0b57a0b21d281d77c6">begin</a> ()</td></tr>
<tr class="memdesc:a2a2ee4c56f511d0b57a0b21d281d77c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of container.  <a href="#a2a2ee4c56f511d0b57a0b21d281d77c6">More...</a><br /></td></tr>
<tr class="separator:a2a2ee4c56f511d0b57a0b21d281d77c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45524b3396f750dc65edeef4d1f0ab23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a45524b3396f750dc65edeef4d1f0ab23">begin</a> () const</td></tr>
<tr class="memdesc:a45524b3396f750dc65edeef4d1f0ab23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of container (const version).  <a href="#a45524b3396f750dc65edeef4d1f0ab23">More...</a><br /></td></tr>
<tr class="separator:a45524b3396f750dc65edeef4d1f0ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837fe722ae18c05dfaf2ec46bfe5519c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a837fe722ae18c05dfaf2ec46bfe5519c">cbegin</a> () const</td></tr>
<tr class="memdesc:a837fe722ae18c05dfaf2ec46bfe5519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of container (const version).  <a href="#a837fe722ae18c05dfaf2ec46bfe5519c">More...</a><br /></td></tr>
<tr class="separator:a837fe722ae18c05dfaf2ec46bfe5519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ee3fcb01b75d4dc975733e70fe4a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f">end</a> ()</td></tr>
<tr class="memdesc:a91ee3fcb01b75d4dc975733e70fe4a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of container.  <a href="#a91ee3fcb01b75d4dc975733e70fe4a8f">More...</a><br /></td></tr>
<tr class="separator:a91ee3fcb01b75d4dc975733e70fe4a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add567dbf63faf6857426ba79c6c226c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#add567dbf63faf6857426ba79c6c226c6">end</a> () const</td></tr>
<tr class="memdesc:add567dbf63faf6857426ba79c6c226c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of container (const version).  <a href="#add567dbf63faf6857426ba79c6c226c6">More...</a><br /></td></tr>
<tr class="separator:add567dbf63faf6857426ba79c6c226c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f77e9dc32a030df172171f24f7f0ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba">cend</a> () const</td></tr>
<tr class="memdesc:a10f77e9dc32a030df172171f24f7f0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of container (const version).  <a href="#a10f77e9dc32a030df172171f24f7f0ba">More...</a><br /></td></tr>
<tr class="separator:a10f77e9dc32a030df172171f24f7f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa267e17f79e0b31f56afd904c00e9821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa267e17f79e0b31f56afd904c00e9821">rbegin</a> ()</td></tr>
<tr class="memdesc:aa267e17f79e0b31f56afd904c00e9821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of container (in reverse).  <a href="#aa267e17f79e0b31f56afd904c00e9821">More...</a><br /></td></tr>
<tr class="separator:aa267e17f79e0b31f56afd904c00e9821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8a215368a25f6c922c37e6bba53ec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4a8a215368a25f6c922c37e6bba53ec6">rbegin</a> () const</td></tr>
<tr class="memdesc:a4a8a215368a25f6c922c37e6bba53ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of container (in reverse - const version).  <a href="#a4a8a215368a25f6c922c37e6bba53ec6">More...</a><br /></td></tr>
<tr class="separator:a4a8a215368a25f6c922c37e6bba53ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad511e47a59848332614493e7f227cc55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad511e47a59848332614493e7f227cc55">crbegin</a> () const</td></tr>
<tr class="memdesc:ad511e47a59848332614493e7f227cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to beginning of container (in reverse - const version).  <a href="#ad511e47a59848332614493e7f227cc55">More...</a><br /></td></tr>
<tr class="separator:ad511e47a59848332614493e7f227cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0271e0394a646489894fed5eab52bbc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0271e0394a646489894fed5eab52bbc0">rend</a> ()</td></tr>
<tr class="memdesc:a0271e0394a646489894fed5eab52bbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of container (in reverse).  <a href="#a0271e0394a646489894fed5eab52bbc0">More...</a><br /></td></tr>
<tr class="separator:a0271e0394a646489894fed5eab52bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5af7653d7d3b39d8212ac764cb96a1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab5af7653d7d3b39d8212ac764cb96a1a">rend</a> () const</td></tr>
<tr class="memdesc:ab5af7653d7d3b39d8212ac764cb96a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of container (in reverse - const version).  <a href="#ab5af7653d7d3b39d8212ac764cb96a1a">More...</a><br /></td></tr>
<tr class="separator:ab5af7653d7d3b39d8212ac764cb96a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05ce1564ff14ef40517bd15438c24b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac05ce1564ff14ef40517bd15438c24b4">crend</a> () const</td></tr>
<tr class="memdesc:ac05ce1564ff14ef40517bd15438c24b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to end of container (in reverse - const version).  <a href="#ac05ce1564ff14ef40517bd15438c24b4">More...</a><br /></td></tr>
<tr class="separator:ac05ce1564ff14ef40517bd15438c24b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f979642fed13d2368a933c483b8ecff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a3f979642fed13d2368a933c483b8ecff">empty</a> () const</td></tr>
<tr class="memdesc:a3f979642fed13d2368a933c483b8ecff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if container is empty.  <a href="#a3f979642fed13d2368a933c483b8ecff">More...</a><br /></td></tr>
<tr class="separator:a3f979642fed13d2368a933c483b8ecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7616823fef209abf325571aa0cfc1e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a7616823fef209abf325571aa0cfc1e38">size</a> () const</td></tr>
<tr class="memdesc:a7616823fef209abf325571aa0cfc1e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's size.  <a href="#a7616823fef209abf325571aa0cfc1e38">More...</a><br /></td></tr>
<tr class="separator:a7616823fef209abf325571aa0cfc1e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d770c81e1ebb522e19e0b2bd626135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad6d770c81e1ebb522e19e0b2bd626135">max_size</a> () const</td></tr>
<tr class="memdesc:ad6d770c81e1ebb522e19e0b2bd626135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's max size.  <a href="#ad6d770c81e1ebb522e19e0b2bd626135">More...</a><br /></td></tr>
<tr class="separator:ad6d770c81e1ebb522e19e0b2bd626135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aac40e15d1cf8e35ed7bf77982d27e4"><td class="memTemplParams" colspan="2">template&lt;class  = std::enable_if_t&lt;has_reserve_method&lt;container_impl, size_type&gt;::value, void&gt;&gt; </td></tr>
<tr class="memitem:a8aac40e15d1cf8e35ed7bf77982d27e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a8aac40e15d1cf8e35ed7bf77982d27e4">reserve</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> new_cap)</td></tr>
<tr class="memdesc:a8aac40e15d1cf8e35ed7bf77982d27e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves capacity in the container.  <a href="#a8aac40e15d1cf8e35ed7bf77982d27e4">More...</a><br /></td></tr>
<tr class="separator:a8aac40e15d1cf8e35ed7bf77982d27e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae128071714f7bca92cdac4ec656384d4"><td class="memTemplParams" colspan="2">template&lt;class  = std::enable_if_t&lt;has_capacity_const_method&lt;container_impl&gt;::value, void&gt;&gt; </td></tr>
<tr class="memitem:ae128071714f7bca92cdac4ec656384d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae128071714f7bca92cdac4ec656384d4">capacity</a> () const</td></tr>
<tr class="memdesc:ae128071714f7bca92cdac4ec656384d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns container's capacity.  <a href="#ae128071714f7bca92cdac4ec656384d4">More...</a><br /></td></tr>
<tr class="separator:ae128071714f7bca92cdac4ec656384d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b05c46b0b9c01972c1cc7f274390665"><td class="memTemplParams" colspan="2">template&lt;class  = std::enable_if_t&lt;has_shrink_to_fit_method&lt;container_impl&gt;::value, void&gt;&gt; </td></tr>
<tr class="memitem:a0b05c46b0b9c01972c1cc7f274390665"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0b05c46b0b9c01972c1cc7f274390665">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a0b05c46b0b9c01972c1cc7f274390665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes memory for size.  <a href="#a0b05c46b0b9c01972c1cc7f274390665">More...</a><br /></td></tr>
<tr class="separator:a0b05c46b0b9c01972c1cc7f274390665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383308f3e0865bfce819ef09064500b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a383308f3e0865bfce819ef09064500b5">insert</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a383308f3e0865bfce819ef09064500b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element in the container.  <a href="#a383308f3e0865bfce819ef09064500b5">More...</a><br /></td></tr>
<tr class="separator:a383308f3e0865bfce819ef09064500b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8614ae570fdb34286137449151250e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a8614ae570fdb34286137449151250e54">insert</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a8614ae570fdb34286137449151250e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves an element in the container.  <a href="#a8614ae570fdb34286137449151250e54">More...</a><br /></td></tr>
<tr class="separator:a8614ae570fdb34286137449151250e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6625aa2e8a3aeebea7531c3fe2377cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6625aa2e8a3aeebea7531c3fe2377cf2">insert</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> hint, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a6625aa2e8a3aeebea7531c3fe2377cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the container with a hint iterator.  <a href="#a6625aa2e8a3aeebea7531c3fe2377cf2">More...</a><br /></td></tr>
<tr class="separator:a6625aa2e8a3aeebea7531c3fe2377cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ec582c79a10d23a62d86bb982df6a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac3ec582c79a10d23a62d86bb982df6a4">insert</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> hint, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:ac3ec582c79a10d23a62d86bb982df6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves an element in the container with a hint iterator.  <a href="#ac3ec582c79a10d23a62d86bb982df6a4">More...</a><br /></td></tr>
<tr class="separator:ac3ec582c79a10d23a62d86bb982df6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765259281f12572e5d7b0ad2dff67b68"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:a765259281f12572e5d7b0ad2dff67b68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a765259281f12572e5d7b0ad2dff67b68">insert</a> (It first, It last)</td></tr>
<tr class="memdesc:a765259281f12572e5d7b0ad2dff67b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a range of elements in the container.  <a href="#a765259281f12572e5d7b0ad2dff67b68">More...</a><br /></td></tr>
<tr class="separator:a765259281f12572e5d7b0ad2dff67b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6693556ad44a016acd72a0f40eb6b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#afb6693556ad44a016acd72a0f40eb6b1">insert</a> (std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt; init)</td></tr>
<tr class="memdesc:afb6693556ad44a016acd72a0f40eb6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from an initializer list in the container.  <a href="#afb6693556ad44a016acd72a0f40eb6b1">More...</a><br /></td></tr>
<tr class="separator:afb6693556ad44a016acd72a0f40eb6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba2e8dbc6ad9be4f4ccaf45dc0908c8"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a6ba2e8dbc6ad9be4f4ccaf45dc0908c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6ba2e8dbc6ad9be4f4ccaf45dc0908c8">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6ba2e8dbc6ad9be4f4ccaf45dc0908c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new element in the container.  <a href="#a6ba2e8dbc6ad9be4f4ccaf45dc0908c8">More...</a><br /></td></tr>
<tr class="separator:a6ba2e8dbc6ad9be4f4ccaf45dc0908c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2832c19ba53a73adf07b6b5749de539b"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a2832c19ba53a73adf07b6b5749de539b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2832c19ba53a73adf07b6b5749de539b">emplace_hint</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2832c19ba53a73adf07b6b5749de539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new element in the container with a hint iterator.  <a href="#a2832c19ba53a73adf07b6b5749de539b">More...</a><br /></td></tr>
<tr class="separator:a2832c19ba53a73adf07b6b5749de539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856626066b0a87cfcc98c5990313305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad856626066b0a87cfcc98c5990313305">erase</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ad856626066b0a87cfcc98c5990313305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the container.  <a href="#ad856626066b0a87cfcc98c5990313305">More...</a><br /></td></tr>
<tr class="separator:ad856626066b0a87cfcc98c5990313305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b1ec574842b69305c1a224753998a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac84b1ec574842b69305c1a224753998a">erase</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> first, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> last)</td></tr>
<tr class="memdesc:ac84b1ec574842b69305c1a224753998a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes many elements from the container.  <a href="#ac84b1ec574842b69305c1a224753998a">More...</a><br /></td></tr>
<tr class="separator:ac84b1ec574842b69305c1a224753998a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5100b5805d132a365395a63f3e632f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a7e5100b5805d132a365395a63f3e632f">erase</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a7e5100b5805d132a365395a63f3e632f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements by key.  <a href="#a7e5100b5805d132a365395a63f3e632f">More...</a><br /></td></tr>
<tr class="separator:a7e5100b5805d132a365395a63f3e632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d16eded4175722b52af2eadb868d4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1d16eded4175722b52af2eadb868d4e5">clear</a> ()</td></tr>
<tr class="memdesc:a1d16eded4175722b52af2eadb868d4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all elements.  <a href="#a1d16eded4175722b52af2eadb868d4e5">More...</a><br /></td></tr>
<tr class="separator:a1d16eded4175722b52af2eadb868d4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0638d67f4cba1dd2367440c66eb22809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0638d67f4cba1dd2367440c66eb22809">swap</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;obj)</td></tr>
<tr class="memdesc:a0638d67f4cba1dd2367440c66eb22809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two containers.  <a href="#a0638d67f4cba1dd2367440c66eb22809">More...</a><br /></td></tr>
<tr class="separator:a0638d67f4cba1dd2367440c66eb22809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a60afc717fcb961d9b6fb0522a73741"><td class="memTemplParams" colspan="2">template&lt;class OT , bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </td></tr>
<tr class="memitem:a6a60afc717fcb961d9b6fb0522a73741"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6a60afc717fcb961d9b6fb0522a73741">insert_or_assign</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key, OT &amp;&amp;val)</td></tr>
<tr class="memdesc:a6a60afc717fcb961d9b6fb0522a73741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or assigns a value.  <a href="#a6a60afc717fcb961d9b6fb0522a73741">More...</a><br /></td></tr>
<tr class="separator:a6a60afc717fcb961d9b6fb0522a73741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f0e964db100b4acdccedc02c3e572d"><td class="memTemplParams" colspan="2">template&lt;class OT , bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </td></tr>
<tr class="memitem:a26f0e964db100b4acdccedc02c3e572d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a26f0e964db100b4acdccedc02c3e572d">insert_or_assign</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&amp;key, OT &amp;&amp;val)</td></tr>
<tr class="memdesc:a26f0e964db100b4acdccedc02c3e572d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or assigns a value (move key version).  <a href="#a26f0e964db100b4acdccedc02c3e572d">More...</a><br /></td></tr>
<tr class="separator:a26f0e964db100b4acdccedc02c3e572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f5225ad7dc8ae893d0fa5c43fcea3a"><td class="memTemplParams" colspan="2">template&lt;class... Args, bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </td></tr>
<tr class="memitem:a99f5225ad7dc8ae893d0fa5c43fcea3a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a99f5225ad7dc8ae893d0fa5c43fcea3a">try_emplace</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a99f5225ad7dc8ae893d0fa5c43fcea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an element in the container.  <a href="#a99f5225ad7dc8ae893d0fa5c43fcea3a">More...</a><br /></td></tr>
<tr class="separator:a99f5225ad7dc8ae893d0fa5c43fcea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac097eeb712c5082af87d6b1475f9f234"><td class="memTemplParams" colspan="2">template&lt;class... Args, bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </td></tr>
<tr class="memitem:ac097eeb712c5082af87d6b1475f9f234"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac097eeb712c5082af87d6b1475f9f234">try_emplace</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac097eeb712c5082af87d6b1475f9f234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an element in the container (move key version).  <a href="#ac097eeb712c5082af87d6b1475f9f234">More...</a><br /></td></tr>
<tr class="separator:ac097eeb712c5082af87d6b1475f9f234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeecd7ecf8cc388fc597a547d4553af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1aeecd7ecf8cc388fc597a547d4553af">count</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a1aeecd7ecf8cc388fc597a547d4553af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements associated to a key.  <a href="#a1aeecd7ecf8cc388fc597a547d4553af">More...</a><br /></td></tr>
<tr class="separator:a1aeecd7ecf8cc388fc597a547d4553af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad788bdc064d897137de9859e17495544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad788bdc064d897137de9859e17495544">find</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:ad788bdc064d897137de9859e17495544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an element in the container.  <a href="#ad788bdc064d897137de9859e17495544">More...</a><br /></td></tr>
<tr class="separator:ad788bdc064d897137de9859e17495544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d686ac0d52c405010ac6ddac194f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa0d686ac0d52c405010ac6ddac194f40">find</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:aa0d686ac0d52c405010ac6ddac194f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an element in the container (const version).  <a href="#aa0d686ac0d52c405010ac6ddac194f40">More...</a><br /></td></tr>
<tr class="separator:aa0d686ac0d52c405010ac6ddac194f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9aab00a6fc0d2dab4068509dc6e6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5">lower_bound</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a5e9aab00a6fc0d2dab4068509dc6e6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower bound.  <a href="#a5e9aab00a6fc0d2dab4068509dc6e6b5">More...</a><br /></td></tr>
<tr class="separator:a5e9aab00a6fc0d2dab4068509dc6e6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937cae4090315a42be387213cf8683c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a937cae4090315a42be387213cf8683c1">lower_bound</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a937cae4090315a42be387213cf8683c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower bound (const version).  <a href="#a937cae4090315a42be387213cf8683c1">More...</a><br /></td></tr>
<tr class="separator:a937cae4090315a42be387213cf8683c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c781cbd1b59e9fe2833ea59a7196c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c">upper_bound</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a5f1c781cbd1b59e9fe2833ea59a7196c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's upper bound.  <a href="#a5f1c781cbd1b59e9fe2833ea59a7196c">More...</a><br /></td></tr>
<tr class="separator:a5f1c781cbd1b59e9fe2833ea59a7196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb31490cdfe60f7a7d8c285afac4419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6bb31490cdfe60f7a7d8c285afac4419">upper_bound</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a6bb31490cdfe60f7a7d8c285afac4419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's upper bound (const version).  <a href="#a6bb31490cdfe60f7a7d8c285afac4419">More...</a><br /></td></tr>
<tr class="separator:a6bb31490cdfe60f7a7d8c285afac4419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d8d6bc5a001a82511721db079e1f1a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12d8d6bc5a001a82511721db079e1f1a">equal_range</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a12d8d6bc5a001a82511721db079e1f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower and upper bounds.  <a href="#a12d8d6bc5a001a82511721db079e1f1a">More...</a><br /></td></tr>
<tr class="separator:a12d8d6bc5a001a82511721db079e1f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94186e414a45da00e0f25ccfe626ef6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad94186e414a45da00e0f25ccfe626ef6">equal_range</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:ad94186e414a45da00e0f25ccfe626ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower and upper bounds (const version).  <a href="#ad94186e414a45da00e0f25ccfe626ef6">More...</a><br /></td></tr>
<tr class="separator:ad94186e414a45da00e0f25ccfe626ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2505851970b485783ef80cbf5c39bfef"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a2505851970b485783ef80cbf5c39bfef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2505851970b485783ef80cbf5c39bfef">count</a> (const OK &amp;key) const</td></tr>
<tr class="memdesc:a2505851970b485783ef80cbf5c39bfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements associated to a key using any type of key.  <a href="#a2505851970b485783ef80cbf5c39bfef">More...</a><br /></td></tr>
<tr class="separator:a2505851970b485783ef80cbf5c39bfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654c0c54aa0d547ba4704532964751a"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a3654c0c54aa0d547ba4704532964751a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a3654c0c54aa0d547ba4704532964751a">find</a> (const OK &amp;key)</td></tr>
<tr class="memdesc:a3654c0c54aa0d547ba4704532964751a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an element in the container using any type of key.  <a href="#a3654c0c54aa0d547ba4704532964751a">More...</a><br /></td></tr>
<tr class="separator:a3654c0c54aa0d547ba4704532964751a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092df3dcb31fa9580784a79d350910ca"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a092df3dcb31fa9580784a79d350910ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a092df3dcb31fa9580784a79d350910ca">find</a> (const OK &amp;key) const</td></tr>
<tr class="memdesc:a092df3dcb31fa9580784a79d350910ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an element in the container using any type of key (const version).  <a href="#a092df3dcb31fa9580784a79d350910ca">More...</a><br /></td></tr>
<tr class="separator:a092df3dcb31fa9580784a79d350910ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45024f9e0a37bca240659c1eef9bf8a4"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a45024f9e0a37bca240659c1eef9bf8a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a45024f9e0a37bca240659c1eef9bf8a4">lower_bound</a> (const OK &amp;key)</td></tr>
<tr class="memdesc:a45024f9e0a37bca240659c1eef9bf8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower bound using any type of key.  <a href="#a45024f9e0a37bca240659c1eef9bf8a4">More...</a><br /></td></tr>
<tr class="separator:a45024f9e0a37bca240659c1eef9bf8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd9785d32c09624f4b5bcd2714d1364"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:aafd9785d32c09624f4b5bcd2714d1364"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aafd9785d32c09624f4b5bcd2714d1364">lower_bound</a> (const OK &amp;key) const</td></tr>
<tr class="memdesc:aafd9785d32c09624f4b5bcd2714d1364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower bound using any type of key (const version).  <a href="#aafd9785d32c09624f4b5bcd2714d1364">More...</a><br /></td></tr>
<tr class="separator:aafd9785d32c09624f4b5bcd2714d1364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2af30dd45213652ff4cc8f82feff6f"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a5b2af30dd45213652ff4cc8f82feff6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5b2af30dd45213652ff4cc8f82feff6f">upper_bound</a> (const OK &amp;key)</td></tr>
<tr class="memdesc:a5b2af30dd45213652ff4cc8f82feff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's upper bound using any type of key.  <a href="#a5b2af30dd45213652ff4cc8f82feff6f">More...</a><br /></td></tr>
<tr class="separator:a5b2af30dd45213652ff4cc8f82feff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697dacafcf8920fc3a0107bbad371fa5"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a697dacafcf8920fc3a0107bbad371fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a697dacafcf8920fc3a0107bbad371fa5">upper_bound</a> (const OK &amp;key) const</td></tr>
<tr class="memdesc:a697dacafcf8920fc3a0107bbad371fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's upper bound using any type of key (const version).  <a href="#a697dacafcf8920fc3a0107bbad371fa5">More...</a><br /></td></tr>
<tr class="separator:a697dacafcf8920fc3a0107bbad371fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5858f4aa1b77b29247445f9549452e1"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:ad5858f4aa1b77b29247445f9549452e1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad5858f4aa1b77b29247445f9549452e1">equal_range</a> (const OK &amp;key)</td></tr>
<tr class="memdesc:ad5858f4aa1b77b29247445f9549452e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower and upper bounds using any type of key.  <a href="#ad5858f4aa1b77b29247445f9549452e1">More...</a><br /></td></tr>
<tr class="separator:ad5858f4aa1b77b29247445f9549452e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faccce3357cb6927d353aab64832bdd"><td class="memTemplParams" colspan="2">template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </td></tr>
<tr class="memitem:a4faccce3357cb6927d353aab64832bdd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4faccce3357cb6927d353aab64832bdd">equal_range</a> (const OK &amp;key) const</td></tr>
<tr class="memdesc:a4faccce3357cb6927d353aab64832bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for key's lower and upper bounds using any type of key (const version).  <a href="#a4faccce3357cb6927d353aab64832bdd">More...</a><br /></td></tr>
<tr class="separator:a4faccce3357cb6927d353aab64832bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298421c634f4e952373d62bc525ecc28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a298421c634f4e952373d62bc525ecc28">key_comp</a> () const</td></tr>
<tr class="memdesc:a298421c634f4e952373d62bc525ecc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns key comparator.  <a href="#a298421c634f4e952373d62bc525ecc28">More...</a><br /></td></tr>
<tr class="separator:a298421c634f4e952373d62bc525ecc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3a519dd1ab23d5561fab83b11620d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12921d1e83b7146f0ee0473a5aeb9abf">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af0a3a519dd1ab23d5561fab83b11620d">value_comp</a> () const</td></tr>
<tr class="memdesc:af0a3a519dd1ab23d5561fab83b11620d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value comparator.  <a href="#af0a3a519dd1ab23d5561fab83b11620d">More...</a><br /></td></tr>
<tr class="separator:af0a3a519dd1ab23d5561fab83b11620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2b59e03c452db41d3623bbd33855b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#afd2b59e03c452db41d3623bbd33855b8">get_allocator</a> () const</td></tr>
<tr class="memdesc:afd2b59e03c452db41d3623bbd33855b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns allocator.  <a href="#afd2b59e03c452db41d3623bbd33855b8">More...</a><br /></td></tr>
<tr class="separator:afd2b59e03c452db41d3623bbd33855b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d655319f8b68ce593b264a52c8147f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a03d655319f8b68ce593b264a52c8147f">key_eq</a> () const</td></tr>
<tr class="memdesc:a03d655319f8b68ce593b264a52c8147f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns key equality predicate.  <a href="#a03d655319f8b68ce593b264a52c8147f">More...</a><br /></td></tr>
<tr class="separator:a03d655319f8b68ce593b264a52c8147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f584a4f5447f2a40af78f23eed9bc37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4e7a2e628de794fee63e50acc37626dc">value_equal_to</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4f584a4f5447f2a40af78f23eed9bc37">value_eq</a> () const</td></tr>
<tr class="memdesc:a4f584a4f5447f2a40af78f23eed9bc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value equality predicate.  <a href="#a4f584a4f5447f2a40af78f23eed9bc37">More...</a><br /></td></tr>
<tr class="separator:a4f584a4f5447f2a40af78f23eed9bc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a859efd42021be1f8495b4e29d44b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a65a859efd42021be1f8495b4e29d44b6">sorted</a> () const</td></tr>
<tr class="memdesc:a65a859efd42021be1f8495b4e29d44b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if container is sorted.  <a href="#a65a859efd42021be1f8495b4e29d44b6">More...</a><br /></td></tr>
<tr class="separator:a65a859efd42021be1f8495b4e29d44b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451f6f8c605c0cb6a0c253208275fcf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a451f6f8c605c0cb6a0c253208275fcf3">sort</a> ()</td></tr>
<tr class="memdesc:a451f6f8c605c0cb6a0c253208275fcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces container to sort elements.  <a href="#a451f6f8c605c0cb6a0c253208275fcf3">More...</a><br /></td></tr>
<tr class="separator:a451f6f8c605c0cb6a0c253208275fcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2c909a28b0c195bb6f822d341e9032ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2c909a28b0c195bb6f822d341e9032ac">operator==</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;left, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;right)</td></tr>
<tr class="memdesc:a2c909a28b0c195bb6f822d341e9032ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a2c909a28b0c195bb6f822d341e9032ac">More...</a><br /></td></tr>
<tr class="separator:a2c909a28b0c195bb6f822d341e9032ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ee3b8c77113c452288d4abaabd9ec4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af3ee3b8c77113c452288d4abaabd9ec4">operator!=</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;left, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;right)</td></tr>
<tr class="memdesc:af3ee3b8c77113c452288d4abaabd9ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#af3ee3b8c77113c452288d4abaabd9ec4">More...</a><br /></td></tr>
<tr class="separator:af3ee3b8c77113c452288d4abaabd9ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935e95f6e8c947256e4b98e30e32ca5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a935e95f6e8c947256e4b98e30e32ca5e">operator&lt;</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;left, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;right)</td></tr>
<tr class="memdesc:a935e95f6e8c947256e4b98e30e32ca5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less than" comparison operator.  <a href="#a935e95f6e8c947256e4b98e30e32ca5e">More...</a><br /></td></tr>
<tr class="separator:a935e95f6e8c947256e4b98e30e32ca5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531b24721ee1597cbf37c2b72d8544c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a531b24721ee1597cbf37c2b72d8544c3">operator&lt;=</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;left, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;right)</td></tr>
<tr class="memdesc:a531b24721ee1597cbf37c2b72d8544c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Less than or equal to" comparison operator.  <a href="#a531b24721ee1597cbf37c2b72d8544c3">More...</a><br /></td></tr>
<tr class="separator:a531b24721ee1597cbf37c2b72d8544c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b9cf6befbe77a5a9f3905d9720533d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac2b9cf6befbe77a5a9f3905d9720533d">operator&gt;</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;left, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;right)</td></tr>
<tr class="memdesc:ac2b9cf6befbe77a5a9f3905d9720533d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Greater than" comparison operator.  <a href="#ac2b9cf6befbe77a5a9f3905d9720533d">More...</a><br /></td></tr>
<tr class="separator:ac2b9cf6befbe77a5a9f3905d9720533d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3a0ed51d253cce51f62285c379b97c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#acd3a0ed51d253cce51f62285c379b97c">operator&gt;=</a> (const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;left, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;right)</td></tr>
<tr class="memdesc:acd3a0ed51d253cce51f62285c379b97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Greater than or equal to" comparison operator.  <a href="#acd3a0ed51d253cce51f62285c379b97c">More...</a><br /></td></tr>
<tr class="separator:acd3a0ed51d253cce51f62285c379b97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815adea74ee29cef0e9fd83357584455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a815adea74ee29cef0e9fd83357584455">swap</a> (<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;obj1, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> &amp;obj2)</td></tr>
<tr class="memdesc:a815adea74ee29cef0e9fd83357584455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two containers (ADL version).  <a href="#a815adea74ee29cef0e9fd83357584455">More...</a><br /></td></tr>
<tr class="separator:a815adea74ee29cef0e9fd83357584455"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class K, class T, class V, class PubV, class VToK, class KCmp, class KEq, class Alloc, template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt;<br />
class coveo::lazy::detail::lazy_sorted_container&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;</h3>

<p>Implementation of a container that maintains a sorted set of elements, like <code>std::set</code> or <code>std::map</code>. The container uses another container internally to store elements in order to optimize size and speed; the container is sorted only when needed (or it can be triggered on-demand).</p>
<p>This class meets the requirements of <code>Container</code>, <code>ReversibleContainer</code>, <code>AllocatorAwareContainer</code> and <code>AssociativeContainer</code>. Furthermore, the internal container type must meet the requirements of <code>Container</code>, <code>ReversibleContainer</code>, <code>AllocatorAwareContainer</code> and <code>SequenceContainer</code>. For details on those concepts, see <a href="http://en.cppreference.com/w/cpp/concept">http://en.cppreference.com/w/cpp/concept</a></p>
<p>This class is not thread-safe; furthermore, because it performs on-demand sorting, there are only two ways of using it in a multi-threaded context:</p><ul>
<li>Protect it with an exclusive mutex like <code>std::mutex</code>, or</li>
<li>Protect it with a shared mutex like <code>std::shared_mutex</code> and make sure that it is always sorted before writer threads release their write locks.</li>
</ul>
<p>If this container is a map (e.g., type <code>T</code> is not <code>void</code>), this class will additionally have a <code>mapped_type</code> typedef (defined as <code>T</code>). Furthermore, if the map does not accept duplicates (e.g., <code>Multi</code> is <code>false</code>), the following additional methods are included:</p>
<ul>
<li><code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0a4cef589df8fc66eed7fe6bf97b8195" title="Accesses an existing element. ">at()</a></code></li>
<li><code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6679a1cfc0ae878ccb00968bc50f39da" title="Accesses an element, possibly creating it. ">operator[]()</a></code></li>
<li><code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6a60afc717fcb961d9b6fb0522a73741" title="Inserts or assigns a value. ">insert_or_assign()</a></code></li>
<li><code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a99f5225ad7dc8ae893d0fa5c43fcea3a" title="Tries to construct an element in the container. ">try_emplace()</a></code></li>
</ul>
<p>Note, however, that those methods all require the container to be sorted to work, so they could be less efficient that blind inserts.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Type of keys used to sort elements in the container. </td></tr>
    <tr><td class="paramname">T</td><td>Type of values bound to each key. If this is set to <code>void</code>, the container is assumed to be a set (like <code>std::set</code>) and its iterators will always return const references. Otherwise, this is assumed to be a map (like <code>std::map</code>) and will contain extra elements (see above). </td></tr>
    <tr><td class="paramname">V</td><td>Type of elements stored in the container. </td></tr>
    <tr><td class="paramname">PubV</td><td>Type of elements that container should appear to contain. Iterators will return references to this type. Must either be the same as <code>V</code> or a derived type (e.g., <code>std::is_base_of&lt;PubV, V&gt;::value</code> is <code>true</code>). </td></tr>
    <tr><td class="paramname">VToK</td><td>Predicate that, given a <code>const V&amp;</code>, will return the key to use to sort the element. For best performance, this should be a <code>const K&amp;</code> pointing to a key inside the element. </td></tr>
    <tr><td class="paramname">KCmp</td><td>Predicate used to compare keys. </td></tr>
    <tr><td class="paramname">KEq</td><td>Predicate used to test keys for equality. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of allocator to use for the underlying storage. </td></tr>
    <tr><td class="paramname">Impl</td><td>Type of container to use for internal storage. Must have the same template parameters as <code>std::vector/deque/etc.</code> </td></tr>
    <tr><td class="paramname">Multi</td><td>Whether container is allowed to have duplicates. Set this to <code>true</code> for <code>std::multiset/multimap</code>-like containers. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1070c870bcc7121d722e529091d7db5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1070c870bcc7121d722e529091d7db5c">&#9670;&nbsp;</a></span>container_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1070c870bcc7121d722e529091d7db5c">container_impl</a> =  Impl&lt;V, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of container used internally to store the elements. Usually a contiguous container offering efficient insertion at the back. Defaults to <code>std::vector</code>. </p>

</div>
</div>
<a id="a71ba0ad7eac9d43f801936289bfd02ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba0ad7eac9d43f801936289bfd02ca">&#9670;&nbsp;</a></span>iterator_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71ba0ad7eac9d43f801936289bfd02ca">iterator_impl</a> =  typename container_impl::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <code>iterator</code> by the internal container. Not used directly, but conditionally to define <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461" title="Iterator for the container. ">lazy_sorted_container::iterator</a></code>. </p>

</div>
</div>
<a id="ae519484d4c227157bd1eb7be058bc451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae519484d4c227157bd1eb7be058bc451">&#9670;&nbsp;</a></span>const_iterator_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae519484d4c227157bd1eb7be058bc451">const_iterator_impl</a> =  typename container_impl::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <code>const_iterator</code> by the internal container. Not used directly, but conditionally to define <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code>. </p>

</div>
</div>
<a id="a16eea9bb86b455cc9e0db77d7b1b921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16eea9bb86b455cc9e0db77d7b1b921a">&#9670;&nbsp;</a></span>reverse_iterator_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a16eea9bb86b455cc9e0db77d7b1b921a">reverse_iterator_impl</a> =  typename container_impl::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <code>reverse_iterator</code> by the internal container. Not used directly, but conditionally to define <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84" title="Reverse iterator for the container. ">lazy_sorted_container::reverse_iterator</a></code>. </p>

</div>
</div>
<a id="af041cae494495d51d4f4d0b7efb1825f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af041cae494495d51d4f4d0b7efb1825f">&#9670;&nbsp;</a></span>const_reverse_iterator_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af041cae494495d51d4f4d0b7efb1825f">const_reverse_iterator_impl</a> =  typename container_impl::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <code>const_reverse_iterator</code> by the internal container. Not used directly, but conditionally to define <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac" title="Const reverse iterator for the container. ">lazy_sorted_container::const_reverse_iterator</a></code>. </p>

</div>
</div>
<a id="a928d87e2c555de098553572019237979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928d87e2c555de098553572019237979">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> =  K</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of keys used in the container. For sets, this is the same as <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5" title="Type of elements stored in the container. ">lazy_sorted_container::value_type</a></code>; for maps, this is a different type. Keys are used to perform lookups in the container (e.g. <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad788bdc064d897137de9859e17495544" title="Looks for an element in the container. ">find()</a></code>, <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lower_bound()</a></code>, etc.) </p>

</div>
</div>
<a id="a2a1adb4d1df12a412203b3c430ec2fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1adb4d1df12a412203b3c430ec2fe5">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> =  PubV</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the elements, or "values", stored in the container. For sets, this is the same type as <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979" title="Type of keys used by the container. ">lazy_sorted_container::key_type</a></code>; for maps, this corresponds to a key/value pair. </p>

</div>
</div>
<a id="ad190c239a267ade61f32b53d36bc7756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad190c239a267ade61f32b53d36bc7756">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> =  typename container_impl::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type used to represent the size of the container, e.g. the number of elements it contains. Corresponds to the type used by the internal container (usually <code>std::size_t</code>). </p>

</div>
</div>
<a id="aa06dab66acc7c765937c610f340d5fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06dab66acc7c765937c610f340d5fe3">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa06dab66acc7c765937c610f340d5fe3">difference_type</a> =  typename container_impl::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type used to represent the difference between two positions in the container. Corresponds to the type used by the internal container (usually <code>std::ptrdiff_t</code>). </p>

</div>
</div>
<a id="a71901dcea412345113a8c68e2ac2a7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71901dcea412345113a8c68e2ac2a7cf">&#9670;&nbsp;</a></span>value_to_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf">value_to_key</a> =  VToK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predicate that, given a container element or "value", can extract its key. This is used internally to keep values sorted. For sets, this predicate simply returns the value itself; for maps, it returns the pair's <code>first</code> member. </p>

</div>
</div>
<a id="aaf9790c06988eb20ef24e9a31fb9f693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9790c06988eb20ef24e9a31fb9f693">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> =  KCmp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predicate that can compare keys and tell if one is "less" (e.g. goes before) the other. This predicate must impose a strict ordering of the keys. Used internally to keep values sorted and to perform lookups. </p>

</div>
</div>
<a id="a12921d1e83b7146f0ee0473a5aeb9abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12921d1e83b7146f0ee0473a5aeb9abf">&#9670;&nbsp;</a></span>value_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12921d1e83b7146f0ee0473a5aeb9abf">value_compare</a> =  lazy_value_pred_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf">value_to_key</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>, but compares values directly by using <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf" title="Predicate to get keys from values. ">lazy_sorted_container::value_to_key</a></code> to extract a key for each value compared. </p>

</div>
</div>
<a id="aa1058770dfbe6eaa26f4932621baa3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1058770dfbe6eaa26f4932621baa3b1">&#9670;&nbsp;</a></span>key_equal_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> =  KEq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predicate that can compare keys and if one is equal to the other. Used internally to identify duplicates if needed (e.g., not a <code>multimap</code> or <code>multiset</code>). </p>

</div>
</div>
<a id="a4e7a2e628de794fee63e50acc37626dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7a2e628de794fee63e50acc37626dc">&#9670;&nbsp;</a></span>value_equal_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4e7a2e628de794fee63e50acc37626dc">value_equal_to</a> =  lazy_value_pred_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf">value_to_key</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1" title="Predicate to check keys for equality. ">lazy_sorted_container::key_equal_to</a></code>, but compares values directly by using <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71901dcea412345113a8c68e2ac2a7cf" title="Predicate to get keys from values. ">lazy_sorted_container::value_to_key</a></code> to extract a key for each value compared. </p>

</div>
</div>
<a id="ab15ef0131b874fe7fba7814417220af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15ef0131b874fe7fba7814417220af6">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> =  typename container_impl::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of allocator used to allocate memory in the container. Defaults to the allocator used by the internal container, which is usually <code>std::allocator</code> in the end. </p>

</div>
</div>
<a id="ae8da0ff3acebc50a10290908b2f199d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8da0ff3acebc50a10290908b2f199d0">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae8da0ff3acebc50a10290908b2f199d0">reference</a> =  std::conditional_t&lt;std::is_void&lt;T&gt;::value, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>&amp;, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of reference returned by the container's <code>iterator</code>s. For maps, this is a non-const reference that allows the caller to modify an element; for sets, this is a const reference and this is similar to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af51fb1b903e75a55d2c12af0c4e4d971" title="Type of reference returned by const_iterators. ">lazy_sorted_container::const_reference</a></code>. </p>

</div>
</div>
<a id="af51fb1b903e75a55d2c12af0c4e4d971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51fb1b903e75a55d2c12af0c4e4d971">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af51fb1b903e75a55d2c12af0c4e4d971">const_reference</a> =  const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of reference returned by the container's <code>const_iterator</code>s. Always a const reference regardless of container type. </p>

</div>
</div>
<a id="a074b16ccb091869630e4f6ccda407ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074b16ccb091869630e4f6ccda407ab4">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a074b16ccb091869630e4f6ccda407ab4">pointer</a> =  std::conditional_t&lt;std::is_void&lt;T&gt;::value, const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>*, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of pointer corresponding to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae8da0ff3acebc50a10290908b2f199d0" title="Type of reference returned by iterators. ">lazy_sorted_container::reference</a></code>. For map, this points to a non-const value that can be modified; for sets, this points to a const value and this is similar to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6726689afa484a3a7d6984ae4210c882" title="Type of pointer corresponding to const_reference. ">lazy_sorted_container::const_pointer</a></code>. </p>

</div>
</div>
<a id="a6726689afa484a3a7d6984ae4210c882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6726689afa484a3a7d6984ae4210c882">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a6726689afa484a3a7d6984ae4210c882">const_pointer</a> =  const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of pointer corresponding to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af51fb1b903e75a55d2c12af0c4e4d971" title="Type of reference returned by const_iterators. ">lazy_sorted_container::const_reference</a></code>. Always points to a const value regardless of container type. </p>

</div>
</div>
<a id="ab994d852d9c69036baedda02d49f7461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab994d852d9c69036baedda02d49f7461">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> =  std::conditional_t&lt;std::is_void&lt;T&gt;::value, conditional_iterator_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae519484d4c227157bd1eb7be058bc451">const_iterator_impl</a>, const V, const PubV&gt;, conditional_iterator_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a71ba0ad7eac9d43f801936289bfd02ca">iterator_impl</a>, V, PubV&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator type for this container. For maps, returns non-const references and allows elements to be modified; for sets, this is similar to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code>. </p>

</div>
</div>
<a id="a94d70f01d26bac41bcc86efaf54f63d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d70f01d26bac41bcc86efaf54f63d2">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> =  conditional_iterator_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ae519484d4c227157bd1eb7be058bc451">const_iterator_impl</a>, const V, const PubV&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const iterator type for this container. Always returns const references to the elements regardless of container type. </p>

</div>
</div>
<a id="a159ac69242a5bd742acadbe13083de84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159ac69242a5bd742acadbe13083de84">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84">reverse_iterator</a> =  std::conditional_t&lt;std::is_void&lt;T&gt;::value, conditional_iterator_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af041cae494495d51d4f4d0b7efb1825f">const_reverse_iterator_impl</a>, const V, const PubV&gt;, conditional_iterator_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a16eea9bb86b455cc9e0db77d7b1b921a">reverse_iterator_impl</a>, V, PubV&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator type for this container allowing reverse iteration. For maps, returns non-const references and allows elements to be modified; for sets, this is similar to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac" title="Const reverse iterator for the container. ">lazy_sorted_container::const_reverse_iterator</a></code>. </p>

</div>
</div>
<a id="ac5c621bb82c8805aec32d8d6ae01bcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c621bb82c8805aec32d8d6ae01bcac">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a> =  conditional_iterator_proxy&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#af041cae494495d51d4f4d0b7efb1825f">const_reverse_iterator_impl</a>, const V, const PubV&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Const iterator type for this container allowing reverse iteration. Always returns const references to the elements regardless of container type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afcc5e2058d1e9f7cc73c90f38ad6172e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc5e2058d1e9f7cc73c90f38ad6172e">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Creates an empty container with default predicates. </p>

</div>
</div>
<a id="a1b0d5552d2ec09cf39e636316263f915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0d5552d2ec09cf39e636316263f915">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &amp;&#160;</td>
          <td class="paramname"><em>keq</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with a specific key comparator instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kcmp</td><td><code>key_compare</code> instance to use for this container. </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6" title="Type of allocator used. ">lazy_sorted_container::allocator_type</a></code>. </td></tr>
    <tr><td class="paramname">keq</td><td><code>key_equal_to</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1" title="Predicate to check keys for equality. ">lazy_sorted_container::key_equal_to</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cb6931d816ae8cc48d5b5f1684d8bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb6931d816ae8cc48d5b5f1684d8bd4">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with a specific allocator instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f7de5778254b7eff302b2d7f96daba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7de5778254b7eff302b2d7f96daba1">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcmp</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &amp;&#160;</td>
          <td class="paramname"><em>keq</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that initializes the container with the elements in the range <code>[first, last[</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the range of elements to insert in the container (inclusive). </td></tr>
    <tr><td class="paramname">last</td><td>End of the range of elements to insert in the container (exclusive). </td></tr>
    <tr><td class="paramname">kcmp</td><td><code>key_compare</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6" title="Type of allocator used. ">lazy_sorted_container::allocator_type</a></code>. </td></tr>
    <tr><td class="paramname">keq</td><td><code>key_equal_to</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1" title="Predicate to check keys for equality. ">lazy_sorted_container::key_equal_to</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a678553568e2a992503a632142c4ed969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678553568e2a992503a632142c4ed969">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that initializes the container with the elements in the range <code>[first, last[</code>. Also initializes the allocator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the range of elements to insert in the container (inclusive). </td></tr>
    <tr><td class="paramname">last</td><td>End of the range of elements to insert in the container (exclusive). </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfbe527256110ba9318363d2ddd40034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbe527256110ba9318363d2ddd40034">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Copies the elements of another container of the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d2e266680ccdd9baa14067233d6ab73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2e266680ccdd9baa14067233d6ab73">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that copies the elements of another container but uses a different allocator instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to copy. Everything is copied except its allocator. </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86ced06738c803645ae626bae3f1ca7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ced06738c803645ae626bae3f1ca7e">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Moves the elements of another container into this one; no copy is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to move in this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a980323052a71c20f5d59d1731123bf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980323052a71c20f5d59d1731123bf96">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that moves the elements of another container in this one but uses a different allocator instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to move in this one. Its allocator is not moved. </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae073314ba9d686dd07420ca7b8719202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae073314ba9d686dd07420ca7b8719202">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcmp</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> &amp;&#160;</td>
          <td class="paramname"><em>keq</em> = <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that initializes the container with the elements in the given <code>initializer_list</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td><code>initializer_list</code> containing container's initial elements. </td></tr>
    <tr><td class="paramname">kcmp</td><td><code>key_compare</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6" title="Type of allocator used. ">lazy_sorted_container::allocator_type</a></code>. </td></tr>
    <tr><td class="paramname">keq</td><td><code>key_equal_to</code> instance to use for this container. Defaults to a default-constructed <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1" title="Predicate to check keys for equality. ">lazy_sorted_container::key_equal_to</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8378e179bc9bab9ab391658ce327477a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8378e179bc9bab9ab391658ce327477a">&#9670;&nbsp;</a></span>lazy_sorted_container() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that initializes the container with the elements in the given <code>initializer_list</code>. Also specifies an allocator instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td><code>initializer_list</code> containing container's initial elements. </td></tr>
    <tr><td class="paramname">alloc</td><td><code>allocator_type</code> instance to use for this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a135ddbf38cd8388c1c764fc277975a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ddbf38cd8388c1c764fc277975a11">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&amp; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copies the elements of the given container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>this</code> container. </dd></dl>

</div>
</div>
<a id="a62a3aa85e8d77197e1c909869bde7c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3aa85e8d77197e1c909869bde7c31">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&amp; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. Moves the elements of the given container into this one; no copy is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to move in this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>this</code> container. </dd></dl>

</div>
</div>
<a id="a02b8fa3a736fac2f1ffe55b9b12a059b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b8fa3a736fac2f1ffe55b9b12a059b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&amp; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator that copies the elements in the given <code>initializer_list</code> into this container, replacing its content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td><code>initializer_list</code> containing the elements to copy in this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>this</code> container. </dd></dl>

</div>
</div>
<a id="a0a4cef589df8fc66eed7fe6bf97b8195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4cef589df8fc66eed7fe6bf97b8195">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class _T  = T, class _TRef  = std::enable_if_t&lt;_IsNonMultiMap, _T&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_TRef <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the existing element with the given key. If the container does not have such an element, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the existing element associated with <code>key</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcoveo_1_1lazy_1_1out__of__range.html" title="Out-of-range exception. ">coveo::lazy::out_of_range</a></td><td>No element with that key exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a6c7a835cb5bdd921332747f0647e5a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7a835cb5bdd921332747f0647e5a09">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class _T  = T, class _CTRef  = std::enable_if_t&lt;_IsNonMultiMap, const _T&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_CTRef <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the existing element with the given key. If the container does not have such an element, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the existing element associated with <code>key</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcoveo_1_1lazy_1_1out__of__range.html" title="Out-of-range exception. ">coveo::lazy::out_of_range</a></td><td>No element with that key exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a6679a1cfc0ae878ccb00968bc50f39da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6679a1cfc0ae878ccb00968bc50f39da">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class _T  = T, class _TRef  = std::enable_if_t&lt;_IsNonMultiMap, _T&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_TRef <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element with the given key. If the container does not have such an element, a default-constructed one is added and its reference is returned.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references except for the return value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element associated with <code>key</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a12a6f80012a93e8ad0841e466704437e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a6f80012a93e8ad0841e466704437e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class _T  = T, class _TRef  = std::enable_if_t&lt;_IsNonMultiMap, _T&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_TRef <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element with the given key. If the container does not have such an element, a default-constructed one is added and associated with a key that is move-constructed from <code>key</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references except for the return value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. If the element does not exist, the key is moved to the container and associated with the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element associated with <code>key</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a2a2ee4c56f511d0b57a0b21d281d77c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2ee4c56f511d0b57a0b21d281d77c6">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461" title="Iterator for the container. ">lazy_sorted_container::iterator</a></code> that points to the beginning of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>, it can be used to enumerate the container's elements.</p>
<p>The iterator allows elements to be modified if this container is a map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> to beginning of container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">lazy_sorted_container::end</a> </dd></dl>

</div>
</div>
<a id="a45524b3396f750dc65edeef4d1f0ab23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45524b3396f750dc65edeef4d1f0ab23">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code> that points to the beginning of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>, it can be used to enumerate the container's elements.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> to beginning of container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">lazy_sorted_container::end</a> </dd></dl>

</div>
</div>
<a id="a837fe722ae18c05dfaf2ec46bfe5519c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837fe722ae18c05dfaf2ec46bfe5519c">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code> that points to the beginning of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>, it can be used to enumerate the container's elements.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> to beginning of container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to get a <code>const_iterator</code> for a container even if the container itself is not <code>const</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">lazy_sorted_container::cend</a> </dd></dl>

</div>
</div>
<a id="a91ee3fcb01b75d4dc975733e70fe4a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ee3fcb01b75d4dc975733e70fe4a8f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461" title="Iterator for the container. ">lazy_sorted_container::iterator</a></code> that points to the end of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a2ee4c56f511d0b57a0b21d281d77c6" title="Iterator to beginning of container. ">begin()</a></code>, it can be used to enumerate the container's elements.</p>
<p>The iterator allows elements to be modified if this container is a map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> to end of container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a2ee4c56f511d0b57a0b21d281d77c6" title="Iterator to beginning of container. ">lazy_sorted_container::begin</a> </dd></dl>

</div>
</div>
<a id="add567dbf63faf6857426ba79c6c226c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add567dbf63faf6857426ba79c6c226c6">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code> that points to the end of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a2ee4c56f511d0b57a0b21d281d77c6" title="Iterator to beginning of container. ">begin()</a></code>, it can be used to enumerate the container's elements.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> to end of container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a2ee4c56f511d0b57a0b21d281d77c6" title="Iterator to beginning of container. ">lazy_sorted_container::begin</a> </dd></dl>

</div>
</div>
<a id="a10f77e9dc32a030df172171f24f7f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f77e9dc32a030df172171f24f7f0ba">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code> that points to the end of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a837fe722ae18c05dfaf2ec46bfe5519c" title="Iterator to beginning of container (const version). ">cbegin()</a></code>, it can be used to enumerate the container's elements.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> to end of container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to get a <code>const_iterator</code> for a container even if the container itself is not <code>const</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a837fe722ae18c05dfaf2ec46bfe5519c" title="Iterator to beginning of container (const version). ">lazy_sorted_container::cbegin</a> </dd></dl>

</div>
</div>
<a id="aa267e17f79e0b31f56afd904c00e9821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa267e17f79e0b31f56afd904c00e9821">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84">reverse_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84" title="Reverse iterator for the container. ">lazy_sorted_container::reverse_iterator</a></code> that points to the beginning of a reverse view of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0271e0394a646489894fed5eab52bbc0" title="Iterator to end of container (in reverse). ">rend()</a></code>, it can be used to enumerate the container's elements, but in reverse.</p>
<p>The iterator allows elements to be modified if this container is a map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>reverse_iterator</code> to beginning of container's reverse view. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0271e0394a646489894fed5eab52bbc0" title="Iterator to end of container (in reverse). ">lazy_sorted_container::rend</a> </dd></dl>

</div>
</div>
<a id="a4a8a215368a25f6c922c37e6bba53ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8a215368a25f6c922c37e6bba53ec6">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac" title="Const reverse iterator for the container. ">lazy_sorted_container::const_reverse_iterator</a></code> that points to the beginning of a reverse view of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0271e0394a646489894fed5eab52bbc0" title="Iterator to end of container (in reverse). ">rend()</a></code>, it can be used to enumerate the container's elements, but in reverse.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_reverse_iterator</code> to beginning of container's reverse view. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0271e0394a646489894fed5eab52bbc0" title="Iterator to end of container (in reverse). ">lazy_sorted_container::rend</a> </dd></dl>

</div>
</div>
<a id="ad511e47a59848332614493e7f227cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad511e47a59848332614493e7f227cc55">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac" title="Const reverse iterator for the container. ">lazy_sorted_container::const_reverse_iterator</a></code> that points to the beginning of a reverse view of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac05ce1564ff14ef40517bd15438c24b4" title="Iterator to end of container (in reverse - const version). ">crend()</a></code>, it can be used to enumerate the container's elements, but in reverse.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_reverse_iterator</code> to beginning of container's reverse view. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to get a <code>const_reverse_iterator</code> for a container even if the container itself is not <code>const</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac05ce1564ff14ef40517bd15438c24b4" title="Iterator to end of container (in reverse - const version). ">lazy_sorted_container::crend</a> </dd></dl>

</div>
</div>
<a id="a0271e0394a646489894fed5eab52bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0271e0394a646489894fed5eab52bbc0">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84">reverse_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a159ac69242a5bd742acadbe13083de84" title="Reverse iterator for the container. ">lazy_sorted_container::reverse_iterator</a></code> that points to the end of a reverse view of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa267e17f79e0b31f56afd904c00e9821" title="Iterator to beginning of container (in reverse). ">rbegin()</a></code>, it can be used to enumerate the container's elements, but in reverse.</p>
<p>The iterator allows elements to be modified if this container is a map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>reverse_iterator</code> to end of container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa267e17f79e0b31f56afd904c00e9821" title="Iterator to beginning of container (in reverse). ">lazy_sorted_container::rbegin</a> </dd></dl>

</div>
</div>
<a id="ab5af7653d7d3b39d8212ac764cb96a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5af7653d7d3b39d8212ac764cb96a1a">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac" title="Const reverse iterator for the container. ">lazy_sorted_container::const_reverse_iterator</a></code> that points to the end of a reverse view of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa267e17f79e0b31f56afd904c00e9821" title="Iterator to beginning of container (in reverse). ">rbegin()</a></code>, it can be used to enumerate the container's elements, but in reverse.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_reverse_iterator</code> to end of container. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa267e17f79e0b31f56afd904c00e9821" title="Iterator to beginning of container (in reverse). ">lazy_sorted_container::rbegin</a> </dd></dl>

</div>
</div>
<a id="ac05ce1564ff14ef40517bd15438c24b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05ce1564ff14ef40517bd15438c24b4">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac">const_reverse_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ac5c621bb82c8805aec32d8d6ae01bcac" title="Const reverse iterator for the container. ">lazy_sorted_container::const_reverse_iterator</a></code> that points to the end of a reverse view of this container. Together with <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad511e47a59848332614493e7f227cc55" title="Iterator to beginning of container (in reverse - const version). ">crbegin()</a></code>, it can be used to enumerate the container's elements, but in reverse.</p>
<p>The iterator does not allow elements to be modified.</p>
<dl class="section return"><dt>Returns</dt><dd><code>const_reverse_iterator</code> to end of container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method can be used to get a <code>const_reverse_iterator</code> for a container even if the container itself is not <code>const</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad511e47a59848332614493e7f227cc55" title="Iterator to beginning of container (in reverse - const version). ">lazy_sorted_container::crbegin</a> </dd></dl>

</div>
</div>
<a id="a3f979642fed13d2368a933c483b8ecff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f979642fed13d2368a933c483b8ecff">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container has no element. </dd></dl>

</div>
</div>
<a id="a7616823fef209abf325571aa0cfc1e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7616823fef209abf325571aa0cfc1e38">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements stored in the container.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the container. </dd></dl>

</div>
</div>
<a id="ad6d770c81e1ebb522e19e0b2bd626135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d770c81e1ebb522e19e0b2bd626135">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of elements that can be stored by the container. This might be limited due to internal implementation, element size, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements that can be stored in the container. </dd></dl>

</div>
</div>
<a id="a8aac40e15d1cf8e35ed7bf77982d27e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aac40e15d1cf8e35ed7bf77982d27e4">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class  = std::enable_if_t&lt;has_reserve_method&lt;container_impl, size_type&gt;::value, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a>&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves memory in the container for the given number of elements.</p>
<p>When planning to add a large number of elements whose count is known in advance, reserving the space can save on reallocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>New required capacity. The final capacity after the call is implementation-specific, but guaranteed to be at least equal to <code>new_cap</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if the internal container implementation (e.g. <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1070c870bcc7121d722e529091d7db5c" title="Type of container used internally. ">lazy_sorted_container::container_impl</a></code>) supports it. </dd></dl>

</div>
</div>
<a id="ae128071714f7bca92cdac4ec656384d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae128071714f7bca92cdac4ec656384d4">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class  = std::enable_if_t&lt;has_capacity_const_method&lt;container_impl&gt;::value, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the container's capacity, e.g. how many elements it can contain before having to reallocate memory somehow. This value will be greater than or equal to that returned by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a7616823fef209abf325571aa0cfc1e38" title="Returns container&#39;s size. ">size()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Container's current capacity. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if the internal container implementation (e.g. <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1070c870bcc7121d722e529091d7db5c" title="Type of container used internally. ">lazy_sorted_container::container_impl</a></code>) supports it. </dd></dl>

</div>
</div>
<a id="a0b05c46b0b9c01972c1cc7f274390665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b05c46b0b9c01972c1cc7f274390665">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class  = std::enable_if_t&lt;has_shrink_to_fit_method&lt;container_impl&gt;::value, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asks the container to shrink its internal memory to the minimum required to store its current elements. Depending on the internal container's implementation, this might or might not produce a result.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if the internal container implementation (e.g. <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a1070c870bcc7121d722e529091d7db5c" title="Type of container used internally. ">lazy_sorted_container::container_impl</a></code>) supports it. </dd></dl>

</div>
</div>
<a id="a383308f3e0865bfce819ef09064500b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383308f3e0865bfce819ef09064500b5">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new element in the container.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to support lazy sorting, this method returns <code>void</code> instead of a <code>pair&lt;iterator, bool&gt;</code>. </dd></dl>

</div>
</div>
<a id="a8614ae570fdb34286137449151250e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8614ae570fdb34286137449151250e54">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new element in the container by moving it. If the element supports move semantics, no copy is performed.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Element to move in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to support lazy sorting, this method returns <code>void</code> instead of a <code>pair&lt;iterator, bool&gt;</code>. </dd></dl>

</div>
</div>
<a id="a6625aa2e8a3aeebea7531c3fe2377cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6625aa2e8a3aeebea7531c3fe2377cf2">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new element in the container.</p>
<p>This method accepts a hint iterator, but discards it in order to support lazy sorting.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>Hint iterator; unused. </td></tr>
    <tr><td class="paramname">value</td><td>Element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to support lazy sorting, this method returns <code>void</code> instead of an iterator. </dd></dl>

</div>
</div>
<a id="ac3ec582c79a10d23a62d86bb982df6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ec582c79a10d23a62d86bb982df6a4">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new element in the container by moving it. If the element supports move semantics, no copy is performed.</p>
<p>This method accepts a hint iterator, but discards it in order to support lazy sorting.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>Hint iterator; unused. </td></tr>
    <tr><td class="paramname">value</td><td>Element to move in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to support lazy sorting, this method returns <code>void</code> instead of an iterator. </dd></dl>

</div>
</div>
<a id="a765259281f12572e5d7b0ad2dff67b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765259281f12572e5d7b0ad2dff67b68">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts all elements in the range <code>[first, last[</code> in the container.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of range of elements to insert. </td></tr>
    <tr><td class="paramname">last</td><td>End of range of elements to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6693556ad44a016acd72a0f40eb6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6693556ad44a016acd72a0f40eb6b1">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts all elements in the given <code>initializer_list</code> in the container.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td><code>initializer_list</code> containing the elements to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ba2e8dbc6ad9be4f4ccaf45dc0908c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba2e8dbc6ad9be4f4ccaf45dc0908c8">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new element in the container by forwarding the given arguments to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5" title="Type of elements stored in the container. ">lazy_sorted_container::value_type</a></code>'s constructor.</p>
<p>Note that for maps, <code>value_type</code> is a pair and thus must be constructed using one of <code>std::pair</code>'s constructors.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments that will be forwarded to the element's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to support lazy sorting, this method returns <code>void</code> instead of a <code>pair&lt;iterator, bool&gt;</code>. </dd></dl>

</div>
</div>
<a id="a2832c19ba53a73adf07b6b5749de539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2832c19ba53a73adf07b6b5749de539b">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new element in the container by forwarding the given arguments to <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5" title="Type of elements stored in the container. ">lazy_sorted_container::value_type</a></code>'s constructor.</p>
<p>This method accepts a hint iterator, but discards it in order to support lazy sorting.</p>
<p>Note that for maps, <code>value_type</code> is a pair and thus must be constructed using one of <code>std::pair</code>'s constructors.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>Hint iterator; unused. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments that will be forwarded to the element's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In order to support lazy sorting, this method returns <code>void</code> instead of an <code>iterator</code>. </dd></dl>

</div>
</div>
<a id="ad856626066b0a87cfcc98c5990313305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad856626066b0a87cfcc98c5990313305">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the element pointed to by the given iterator from the container.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator pointing at element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing at element following the removed element or, if the removed element was the last one, at the end of the container. </dd></dl>

</div>
</div>
<a id="ac84b1ec574842b69305c1a224753998a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84b1ec574842b69305c1a224753998a">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements pointed to by iterators in the range <code>[first, last[</code> from the container.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of range of elements to remove. </td></tr>
    <tr><td class="paramname">last</td><td>End of range of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing at element following the last element removed or, if that was the last element, at the end of the container. </dd></dl>

</div>
</div>
<a id="a7e5100b5805d132a365395a63f3e632f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5100b5805d132a365395a63f3e632f">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements associated with the given key from the container.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element(s) to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. For containers that do not accept duplicates, this can never be greater than 1. </dd></dl>

</div>
</div>
<a id="a1d16eded4175722b52af2eadb868d4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d16eded4175722b52af2eadb868d4e5">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all elements from the container. </p>

</div>
</div>
<a id="a0638d67f4cba1dd2367440c66eb22809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0638d67f4cba1dd2367440c66eb22809">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the content of this container with another. After this method returns, this container will contain the elements formely in <code>obj</code> and vice-versa.</p>
<p>Depending on internal container implementation, this is usually done without moving of copying elements; only pointers are swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Container to swap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a60afc717fcb961d9b6fb0522a73741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a60afc717fcb961d9b6fb0522a73741">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OT , bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OT &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the container contains an element associated with <code>key</code>, assigns <code>val</code> (by forwarding it) to its associated value. Otherwise, inserts a new element constructed by copying <code>key</code> and forwarding <code>val</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to insert or assign to. </td></tr>
    <tr><td class="paramname">val</td><td>Value to insert or assign to <code>key</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> whose <code>first</code> element is an <code>iterator</code> pointing at the element in the container and whose <code>second</code> element will be <code>true</code> if element was inserted or <code>false</code> if it was assigned to. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a26f0e964db100b4acdccedc02c3e572d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f0e964db100b4acdccedc02c3e572d">&#9670;&nbsp;</a></span>insert_or_assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OT , bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OT &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the container contains an element associated with <code>key</code>, assigns <code>val</code> (by forwarding it) to its associated value. Otherwise, inserts a new element constructed by moving <code>key</code> and forwarding <code>val</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to move-insert or assign to. </td></tr>
    <tr><td class="paramname">val</td><td>Value to insert or assign to <code>key</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> whose <code>first</code> element is an <code>iterator</code> pointing at the element in the container and whose <code>second</code> element will be <code>true</code> if element was inserted or <code>false</code> if it was assigned to. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a99f5225ad7dc8ae893d0fa5c43fcea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f5225ad7dc8ae893d0fa5c43fcea3a">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class... Args, bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the container already contains an element associated with <code>key</code>, does nothing; otherwise, constructs a new element in the container by copying <code>key</code> and forwarding <code>args</code> to the value's constructor, as if calling</p>
<div class="fragment"><div class="line"><a class="code" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>(std::piecewise_construct,</div><div class="line">           std::forward_as_tuple(key),</div><div class="line">           std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to try adding. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the value's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> whose <code>first</code> element is an <code>iterator</code> pointing at the element in the container and whose <code>second</code> element will be <code>true</code> if element was added or <code>false</code> if it already existed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="ac097eeb712c5082af87d6b1475f9f234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac097eeb712c5082af87d6b1475f9f234">&#9670;&nbsp;</a></span>try_emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class... Args, bool _Enabled = _IsNonMultiMap, class  = std::enable_if_t&lt;_Enabled, void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, bool&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the container already contains an element associated with <code>key</code>, does nothing; otherwise, constructs a new element in the container by moving <code>key</code> and forwarding <code>args</code> to the value's constructor, as if calling</p>
<div class="fragment"><div class="line"><a class="code" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2a1adb4d1df12a412203b3c430ec2fe5">value_type</a>(std::piecewise_construct,</div><div class="line">           std::forward_as_tuple(std::move(key)),</div><div class="line">           std::forward_as_tuple(std::forward&lt;Args&gt;(args)...))</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Invalidates all iterators and references.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to try adding (by moving it). </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the value's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> whose <code>first</code> element is an <code>iterator</code> pointing at the element in the container and whose <code>second</code> element will be <code>true</code> if element was added or <code>false</code> if it already existed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available for non-multi maps. </dd></dl>

</div>
</div>
<a id="a1aeecd7ecf8cc388fc597a547d4553af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeecd7ecf8cc388fc597a547d4553af">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the container that are associated with <code>key</code>. For containers that do not accept duplicates, this will be at most 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element(s) to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements associated with <code>key</code>. </dd></dl>

</div>
</div>
<a id="ad788bdc064d897137de9859e17495544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad788bdc064d897137de9859e17495544">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for an element in the container associated with <code>key</code>. If at least one is found, returns an <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461" title="Iterator for the container. ">lazy_sorted_container::iterator</a></code> pointing at the first such element, otherwise pointing at <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> pointing at element if found, otherwise pointing at the <code>end</code> of the container. </dd></dl>

</div>
</div>
<a id="aa0d686ac0d52c405010ac6ddac194f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d686ac0d52c405010ac6ddac194f40">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for an element in the container associated with <code>key</code>. If at least one is found, returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code> pointing at the first such element, otherwise pointing at <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> pointing at element if found, otherwise pointing at the <code>end</code> of the container. </dd></dl>

</div>
</div>
<a id="a5e9aab00a6fc0d2dab4068509dc6e6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9aab00a6fc0d2dab4068509dc6e6b5">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than or equal to <code>key</code>. This corresponds to the key's "lower bound".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> pointing at first element whose key is greater than or equal to <code>key</code>. If no element is associated with <code>key</code> in the container, returns the first element associated with the next key or possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">lazy_sorted_container::upper_bound</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12d8d6bc5a001a82511721db079e1f1a" title="Looks for key&#39;s lower and upper bounds. ">lazy_sorted_container::equal_range</a> </dd></dl>

</div>
</div>
<a id="a937cae4090315a42be387213cf8683c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937cae4090315a42be387213cf8683c1">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than or equal to <code>key</code>. This corresponds to the key's "lower bound". (<code>const</code> version)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> pointing at first element whose key is greater than or equal to <code>key</code>. If no element is associated with <code>key</code> in the container, returns the first element associated with the next key or possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">lazy_sorted_container::upper_bound</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12d8d6bc5a001a82511721db079e1f1a" title="Looks for key&#39;s lower and upper bounds. ">lazy_sorted_container::equal_range</a> </dd></dl>

</div>
</div>
<a id="a5f1c781cbd1b59e9fe2833ea59a7196c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1c781cbd1b59e9fe2833ea59a7196c">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than <code>key</code>. This corresponds to the key's "upper bound".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> pointing at first element whose key is greater than <code>key</code>, possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lazy_sorted_container::lower_bound</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12d8d6bc5a001a82511721db079e1f1a" title="Looks for key&#39;s lower and upper bounds. ">lazy_sorted_container::equal_range</a> </dd></dl>

</div>
</div>
<a id="a6bb31490cdfe60f7a7d8c285afac4419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb31490cdfe60f7a7d8c285afac4419">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than <code>key</code>. This corresponds to the key's "upper bound". (<code>const</code> version)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> pointing at first element whose key is greater than <code>key</code>, possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lazy_sorted_container::lower_bound</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12d8d6bc5a001a82511721db079e1f1a" title="Looks for key&#39;s lower and upper bounds. ">lazy_sorted_container::equal_range</a> </dd></dl>

</div>
</div>
<a id="a12d8d6bc5a001a82511721db079e1f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d8d6bc5a001a82511721db079e1f1a">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for a key's lower and upper bounds. This is similar to calling <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lower_bound()</a></code> and <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">upper_bound()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> of <code>iterator</code>s, whose <code>first</code> points to the first element in the container whose key is greater than or equal to <code>key</code> and whose <code>second</code> points to the first element whose key is greater than <code>key</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lazy_sorted_container::lower_bound</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">lazy_sorted_container::upper_bound</a> </dd></dl>

</div>
</div>
<a id="ad94186e414a45da00e0f25ccfe626ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94186e414a45da00e0f25ccfe626ef6">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a928d87e2c555de098553572019237979">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for a key's lower and upper bounds. This is similar to calling <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lower_bound()</a></code> and <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">upper_bound()</a></code>. (<code>const</code> version)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> of <code>const_iterator</code>s, whose <code>first</code> points to the first element in the container whose key is greater than or equal to <code>key</code> and whose <code>second</code> points to the first element whose key is greater than <code>key</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lazy_sorted_container::lower_bound</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">lazy_sorted_container::upper_bound</a> </dd></dl>

</div>
</div>
<a id="a2505851970b485783ef80cbf5c39bfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2505851970b485783ef80cbf5c39bfef">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad190c239a267ade61f32b53d36bc7756">size_type</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the container that are associated with <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. For containers that do not accept duplicates, this will be at most 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element(s) to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements associated with <code>key</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>

</div>
</div>
<a id="a3654c0c54aa0d547ba4704532964751a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3654c0c54aa0d547ba4704532964751a">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for an element in the container associated with <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. If at least one is found, returns an <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461" title="Iterator for the container. ">lazy_sorted_container::iterator</a></code> pointing at the first such element, otherwise pointing at <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> pointing at element if found, otherwise pointing at the <code>end</code> of the container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>

</div>
</div>
<a id="a092df3dcb31fa9580784a79d350910ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092df3dcb31fa9580784a79d350910ca">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for an element in the container associated with <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. If at least one is found, returns a <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2" title="Const iterator for the container. ">lazy_sorted_container::const_iterator</a></code> pointing at the first such element, otherwise pointing at <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of element to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> pointing at element if found, otherwise pointing at the <code>end</code> of the container. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>

</div>
</div>
<a id="a45024f9e0a37bca240659c1eef9bf8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45024f9e0a37bca240659c1eef9bf8a4">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than or equal to <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. This corresponds to the key's "lower bound".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> pointing at first element whose key is greater than or equal to <code>key</code>. If no element is associated with <code>key</code> in the container, returns the first element associated with the next key or possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5b2af30dd45213652ff4cc8f82feff6f" title="Looks for key&#39;s upper bound using any type of key. ">lazy_sorted_container::upper_bound(const OK&amp;)</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad5858f4aa1b77b29247445f9549452e1" title="Looks for key&#39;s lower and upper bounds using any type of key. ">lazy_sorted_container::equal_range(const OK&amp;)</a> </dd></dl>

</div>
</div>
<a id="aafd9785d32c09624f4b5bcd2714d1364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd9785d32c09624f4b5bcd2714d1364">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than or equal to <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. This corresponds to the key's "lower bound". (<code>const</code> version)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> pointing at first element whose key is greater than or equal to <code>key</code>. If no element is associated with <code>key</code> in the container, returns the first element associated with the next key or possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5b2af30dd45213652ff4cc8f82feff6f" title="Looks for key&#39;s upper bound using any type of key. ">lazy_sorted_container::upper_bound(const OK&amp;)</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad5858f4aa1b77b29247445f9549452e1" title="Looks for key&#39;s lower and upper bounds using any type of key. ">lazy_sorted_container::equal_range(const OK&amp;)</a> </dd></dl>

</div>
</div>
<a id="a5b2af30dd45213652ff4cc8f82feff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2af30dd45213652ff4cc8f82feff6f">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. This corresponds to the key's "upper bound".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>iterator</code> pointing at first element whose key is greater than <code>key</code>, possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a91ee3fcb01b75d4dc975733e70fe4a8f" title="Iterator to end of container. ">end()</a></code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a45024f9e0a37bca240659c1eef9bf8a4" title="Looks for key&#39;s lower bound using any type of key. ">lazy_sorted_container::lower_bound(const OK&amp;)</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad5858f4aa1b77b29247445f9549452e1" title="Looks for key&#39;s lower and upper bounds using any type of key. ">lazy_sorted_container::equal_range(const OK&amp;)</a> </dd></dl>

</div>
</div>
<a id="a697dacafcf8920fc3a0107bbad371fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697dacafcf8920fc3a0107bbad371fa5">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the first element in the container whose key is greater than <code>key</code>, which can be any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. This corresponds to the key's "upper bound". (<code>const</code> version)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>const_iterator</code> pointing at first element whose key is greater than <code>key</code>, possibly <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a10f77e9dc32a030df172171f24f7f0ba" title="Iterator to end of container (const version). ">cend()</a></code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a45024f9e0a37bca240659c1eef9bf8a4" title="Looks for key&#39;s lower bound using any type of key. ">lazy_sorted_container::lower_bound(const OK&amp;)</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ad5858f4aa1b77b29247445f9549452e1" title="Looks for key&#39;s lower and upper bounds using any type of key. ">lazy_sorted_container::equal_range(const OK&amp;)</a> </dd></dl>

</div>
</div>
<a id="ad5858f4aa1b77b29247445f9549452e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5858f4aa1b77b29247445f9549452e1">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab994d852d9c69036baedda02d49f7461">iterator</a>&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for a key's lower and upper bounds using any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. This is similar to calling <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lower_bound()</a></code> and <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">upper_bound()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> of <code>iterator</code>s, whose <code>first</code> points to the first element in the container whose key is greater than or equal to <code>key</code> and whose <code>second</code> points to the first element whose key is greater than <code>key</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a45024f9e0a37bca240659c1eef9bf8a4" title="Looks for key&#39;s lower bound using any type of key. ">lazy_sorted_container::lower_bound(const OK&amp;)</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5b2af30dd45213652ff4cc8f82feff6f" title="Looks for key&#39;s upper bound using any type of key. ">lazy_sorted_container::upper_bound(const OK&amp;)</a> </dd></dl>

</div>
</div>
<a id="a4faccce3357cb6927d353aab64832bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faccce3357cb6927d353aab64832bdd">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<div class="memtemplate">
template&lt;class OK , class _OKCmp  = key_compare, class  = typename _OKCmp::is_transparent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>, <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a94d70f01d26bac41bcc86efaf54f63d2">const_iterator</a>&gt; <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const OK &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for a key's lower and upper bounds using any type accepted by <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code>. This is similar to calling <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5e9aab00a6fc0d2dab4068509dc6e6b5" title="Looks for key&#39;s lower bound. ">lower_bound()</a></code> and <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5f1c781cbd1b59e9fe2833ea59a7196c" title="Looks for key&#39;s upper bound. ">upper_bound()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pair</code> of <code>const_iterator</code>s, whose <code>first</code> points to the first element in the container whose key is greater than or equal to <code>key</code> and whose <code>second</code> points to the first element whose key is greater than <code>key</code>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method is only available if <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> is a transparent function (e.g. defines <code>is_transparent</code>), like <code>std::less&lt;&gt;</code>. For more info, see <a href="http://en.cppreference.com/w/cpp/utility/functional/less_void">http://en.cppreference.com/w/cpp/utility/functional/less_void</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a45024f9e0a37bca240659c1eef9bf8a4" title="Looks for key&#39;s lower bound using any type of key. ">lazy_sorted_container::lower_bound(const OK&amp;)</a> </dd>
<dd>
<a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a5b2af30dd45213652ff4cc8f82feff6f" title="Looks for key&#39;s upper bound using any type of key. ">lazy_sorted_container::upper_bound(const OK&amp;)</a> </dd></dl>

</div>
</div>
<a id="a298421c634f4e952373d62bc525ecc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298421c634f4e952373d62bc525ecc28">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693">key_compare</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the instance of <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aaf9790c06988eb20ef24e9a31fb9f693" title="Predicate to compare keys. ">lazy_sorted_container::key_compare</a></code> used by the container to compare keys.</p>
<dl class="section return"><dt>Returns</dt><dd>Key comparator instance. </dd></dl>

</div>
</div>
<a id="af0a3a519dd1ab23d5561fab83b11620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a3a519dd1ab23d5561fab83b11620d">&#9670;&nbsp;</a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12921d1e83b7146f0ee0473a5aeb9abf">value_compare</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the instance of <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a12921d1e83b7146f0ee0473a5aeb9abf" title="Predicate to compare values. ">lazy_sorted_container::value_compare</a></code> used by the container to compare elements, or "values".</p>
<dl class="section return"><dt>Returns</dt><dd>Value comparator instance. </dd></dl>

</div>
</div>
<a id="afd2b59e03c452db41d3623bbd33855b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2b59e03c452db41d3623bbd33855b8">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6">allocator_type</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the instance of <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#ab15ef0131b874fe7fba7814417220af6" title="Type of allocator used. ">lazy_sorted_container::allocator_type</a></code> used by the container to allocate memory.</p>
<dl class="section return"><dt>Returns</dt><dd>Allocator instance. </dd></dl>

</div>
</div>
<a id="a03d655319f8b68ce593b264a52c8147f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d655319f8b68ce593b264a52c8147f">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1">key_equal_to</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the instance of <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#aa1058770dfbe6eaa26f4932621baa3b1" title="Predicate to check keys for equality. ">lazy_sorted_container::key_equal_to</a></code> used by the container to determine if two keys are equal.</p>
<dl class="section return"><dt>Returns</dt><dd>Key equality predicate instance. </dd></dl>

</div>
</div>
<a id="a4f584a4f5447f2a40af78f23eed9bc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f584a4f5447f2a40af78f23eed9bc37">&#9670;&nbsp;</a></span>value_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4e7a2e628de794fee63e50acc37626dc">value_equal_to</a> <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::value_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the instance of <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a4e7a2e628de794fee63e50acc37626dc" title="Predicate to check values for equality. ">lazy_sorted_container::value_equal_to</a></code> used by the container to determine if two elements, or "values", are equal.</p>
<dl class="section return"><dt>Returns</dt><dd>Value equality predicate instance. </dd></dl>

</div>
</div>
<a id="a65a859efd42021be1f8495b4e29d44b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a859efd42021be1f8495b4e29d44b6">&#9670;&nbsp;</a></span>sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the elements in the container are currently sorted. Elements could be unsorted following insertions, if no query was performed.</p>
<p>It's possible to trigger sorting by calling <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a451f6f8c605c0cb6a0c253208275fcf3" title="Forces container to sort elements. ">sort()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if elements are currently sorted. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a451f6f8c605c0cb6a0c253208275fcf3" title="Forces container to sort elements. ">lazy_sorted_container::sort</a> </dd></dl>

</div>
</div>
<a id="a451f6f8c605c0cb6a0c253208275fcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451f6f8c605c0cb6a0c253208275fcf3">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">coveo::lazy::detail::lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forces container to sort its elements immediately. Has no effect if elements are already sorted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a65a859efd42021be1f8495b4e29d44b6" title="Checks if container is sorted. ">lazy_sorted_container::sorted</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2c909a28b0c195bb6f822d341e9032ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c909a28b0c195bb6f822d341e9032ac">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator that verifies if two containers contain the same elements. Note: does not use <code>key_equal_to</code> to compare the elements; elements must be <code>EqualityComparable</code> for this to work. For more info, see <a href="http://en.cppreference.com/w/cpp/concept/EqualityComparable">http://en.cppreference.com/w/cpp/concept/EqualityComparable</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First container to compare. </td></tr>
    <tr><td class="paramname">right</td><td>Second container to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>left</code> contains the same elements as <code>right</code>. </dd></dl>

</div>
</div>
<a id="af3ee3b8c77113c452288d4abaabd9ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ee3b8c77113c452288d4abaabd9ec4">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator that verifies if two containers have different elements. For more info, see <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a2c909a28b0c195bb6f822d341e9032ac" title="Equality operator. ">operator==()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First container to compare. </td></tr>
    <tr><td class="paramname">right</td><td>Second container to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>left</code> does not contain the same elements as <code>right</code>. </dd></dl>

</div>
</div>
<a id="a935e95f6e8c947256e4b98e30e32ca5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935e95f6e8c947256e4b98e30e32ca5e">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator that verifies if a container is "less than" another by performing a lexicographical comparison of the elements. Note: does not use <code>key_compare</code> to compare the elements; elements must be <code>LessThanComparable</code> for this to work. For more info, see <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">http://en.cppreference.com/w/cpp/concept/LessThanComparable</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First container to compare. </td></tr>
    <tr><td class="paramname">right</td><td>Second container to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>left</code> is "less than" <code>right</code>. </dd></dl>

</div>
</div>
<a id="a531b24721ee1597cbf37c2b72d8544c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531b24721ee1597cbf37c2b72d8544c3">&#9670;&nbsp;</a></span>operator<=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator that verifies if a container is "less than or equal to" another. For more information, see <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a935e95f6e8c947256e4b98e30e32ca5e" title="&quot;Less than&quot; comparison operator. ">operator&lt;()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First container to compare. </td></tr>
    <tr><td class="paramname">right</td><td>Second container to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>left</code> is "less than or equal to" <code>right</code>. </dd></dl>

</div>
</div>
<a id="ac2b9cf6befbe77a5a9f3905d9720533d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b9cf6befbe77a5a9f3905d9720533d">&#9670;&nbsp;</a></span>operator></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator that verifies if a container is "greater than" another. For more information, see <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a935e95f6e8c947256e4b98e30e32ca5e" title="&quot;Less than&quot; comparison operator. ">operator&lt;()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First container to compare. </td></tr>
    <tr><td class="paramname">right</td><td>Second container to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>left</code> is "greater than" <code>right</code>. </dd></dl>

</div>
</div>
<a id="acd3a0ed51d253cce51f62285c379b97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3a0ed51d253cce51f62285c379b97c">&#9670;&nbsp;</a></span>operator>=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator that verifies if a container is "greater than or equal to" another. For more information, see <code><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a935e95f6e8c947256e4b98e30e32ca5e" title="&quot;Less than&quot; comparison operator. ">operator&lt;()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>First container to compare. </td></tr>
    <tr><td class="paramname">right</td><td>Second container to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>left</code> is "greater than or equal to" <code>right</code>. </dd></dl>

</div>
</div>
<a id="a815adea74ee29cef0e9fd83357584455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815adea74ee29cef0e9fd83357584455">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class V , class PubV , class VToK , class KCmp , class KEq , class Alloc , template&lt; class _ImplT, class _ImplAlloc &gt; class Impl, bool Multi, bool _IsNonMultiMap = !std::is_void&lt;T&gt;::value &amp;&amp; !Multi&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html">lazy_sorted_container</a>&lt; K, T, V, PubV, VToK, KCmp, KEq, Alloc, Impl, Multi, _IsNonMultiMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the content of two containers. After this function returns, <code>obj1</code> will contain the elements formely in <code>obj2</code> and vice-versa.</p>
<p>Depending on internal container implementation, this is usually done without moving of copying elements; only pointers are swapped.</p>
<p>This function is similar to the <code>swap</code> method, but can be found through <a href="http://en.cppreference.com/w/cpp/language/adl">ADL</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classcoveo_1_1lazy_1_1detail_1_1lazy__sorted__container.html#a0638d67f4cba1dd2367440c66eb22809">swap</a>(c1, c2); <span class="comment">// No need for coveo::lazy::...</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj1</td><td>First container to swap. </td></tr>
    <tr><td class="paramname">obj2</td><td>Second container to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>coveo/lazy/detail/<a class="el" href="lazy__sorted__container_8h_source.html">lazy_sorted_container.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 7 2017 22:27:22 for coveo::lazy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
